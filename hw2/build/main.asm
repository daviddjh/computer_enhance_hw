; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG70095 DB	'(os_debug_print) Error: string size is more than 500 cha'
	DB	'racters. Printing first 500.', 0aH, 00H
	ORG $+2
$SG70157 DB	'open_file failed to create file handle! last error: %u', 00H
	ORG $+1
$SG70159 DB	'open_file failed to get file size! last error: %u', 00H
	ORG $+6
$SG70174 DB	'close_file failed!', 00H
	ORG $+5
$SG70189 DB	'[BX + SI]', 00H
	ORG $+6
$SG70191 DB	'[BX + DI]', 00H
	ORG $+6
$SG70193 DB	'[BP + SI]', 00H
	ORG $+6
$SG70195 DB	'[BP + DI]', 00H
	ORG $+2
$SG70197 DB	'[SI]', 00H
	ORG $+3
$SG70199 DB	'[DI]', 00H
	ORG $+3
$SG70201 DB	'%d', 00H
	ORG $+1
$SG70203 DB	'[BX]', 00H
	ORG $+3
$SG70207 DB	'[BX + SI + %d]', 00H
	ORG $+1
$SG70209 DB	'[BX + DI + %d]', 00H
	ORG $+1
$SG70211 DB	'[BP + SI + %d]', 00H
	ORG $+1
$SG70213 DB	'[BP + DI + %d]', 00H
	ORG $+1
$SG70215 DB	'[SI + %d]', 00H
	ORG $+6
$SG70217 DB	'[DI + %d]', 00H
	ORG $+6
$SG70219 DB	'[BP + %d]', 00H
	ORG $+6
$SG70221 DB	'[BX + %d]', 00H
	ORG $+2
$SG70427 DB	'r', 00H
	ORG $+2
$SG70428 DB	'..\..\computer_enhance\perfaware\part1\listing_0039_more'
	DB	'_movs', 00H
	ORG $+2
$SG70431 DB	'mov ', 00H
	ORG $+3
$SG70451 DB	'%.*s, %.*s', 0aH, 00H
$SG70454 DB	'mov ', 00H
	ORG $+7
$SG70457 DB	'%.*s, %d', 0aH, 00H
	ORG $+6
$SG70459 DB	'%.*s, %d', 0aH, 00H
	ORG $+6
$SG70460 DB	'Unrecognized Op Code! : %s', 0aH, 00H
	ORG $+4
$SG72652 DB	'invalid argument', 00H
	ORG $+3
$SG72653 DB	'%s', 00H
	ORG $+1
$SG72654 DB	'C:\Program Files\Microsoft Visual Studio\2022\Community\'
	DB	'VC\Tools\MSVC\14.41.34120\include\xmemory', 00H
	ORG $+14
$SG72655 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H
	DB	'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't'
	DB	00H, ' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H
	DB	'l', 00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i'
	DB	00H, 'o', 00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H
	DB	'\', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n'
	DB	00H, 'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H
	DB	'\', 00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\'
	DB	00H, 'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H
	DB	'4', 00H, '.', 00H, '4', 00H, '1', 00H, '.', 00H, '3', 00H, '4'
	DB	00H, '1', 00H, '2', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x'
	DB	00H, 'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H
	DB	00H, 00H
$SG72656 DB	00H, 00H
	ORG $+2
$SG72657 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AEAA@QEBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UEAA@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QEAA@AEBV01@@Z		; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UEAAPEAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QEAA@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UEAA@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QEAA@AEBV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UEAAPEAXI@Z	; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QEAA@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z ; d_std::d_string::c_str
PUBLIC	?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z ; d_std::string_from_lit_string
PUBLIC	?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ ; d_std::format_lit_string
PUBLIC	?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ; d_std::_format_lit_string
PUBLIC	?os_reserve_memory@d_std@@YA_K_K@Z		; d_std::os_reserve_memory
PUBLIC	?os_commit_memory@d_std@@YAX_K0@Z		; d_std::os_commit_memory
PUBLIC	?os_decommit_memory@d_std@@YAX_K0@Z		; d_std::os_decommit_memory
PUBLIC	?os_release_memory@d_std@@YAX_K@Z		; d_std::os_release_memory
PUBLIC	?os_debug_print@d_std@@YAXPEBD@Z		; d_std::os_debug_print
PUBLIC	?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ ; d_std::os_debug_printf
PUBLIC	?os_debug_print@d_std@@YAXUd_string@1@@Z	; d_std::os_debug_print
PUBLIC	?is_debugger_present@d_std@@YA_NXZ		; d_std::is_debugger_present
PUBLIC	?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z	; d_std::open_file
PUBLIC	?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z ; d_std::read_file
PUBLIC	?close_file@d_std@@YA_NUFile@1@@Z		; d_std::close_file
PUBLIC	?release@Memory_Arena@d_std@@QEAAXXZ		; d_std::Memory_Arena::release
PUBLIC	?reset@Memory_Arena@d_std@@QEAAXXZ		; d_std::Memory_Arena::reset
PUBLIC	?allocate@Memory_Arena@d_std@@QEAA_K_K@Z	; d_std::Memory_Arena::allocate
PUBLIC	?deallocate@Memory_Arena@d_std@@QEAAX_K@Z	; d_std::Memory_Arena::deallocate
PUBLIC	?push@Memory_Arena@d_std@@QEAA_K_K@Z		; d_std::Memory_Arena::push
PUBLIC	?pop_to@Memory_Arena@d_std@@QEAAX_K@Z		; d_std::Memory_Arena::pop_to
PUBLIC	?pop_all@Memory_Arena@d_std@@QEAAXXZ		; d_std::Memory_Arena::pop_all
PUBLIC	?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ	; d_std::make_arena
PUBLIC	?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z	; d_std::make_arena
PUBLIC	?murmur3_32@d_std@@YAIPEAXII@Z			; d_std::murmur3_32
PUBLIC	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
PUBLIC	?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z	; d_std::_format_lit_string
PUBLIC	??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ; d_std::Memory_Arena::deallocate_array<char>
PUBLIC	?os_debug_printf@d_std@@YAXPEBDZZ		; d_std::os_debug_printf
PUBLIC	?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ; decode_effective_address_calculation
PUBLIC	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
PUBLIC	main
PUBLIC	?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z	; std::bitset<8>::_Subscript
PUBLIC	??0?$bitset@$07@std@@QEAA@_K@Z			; std::bitset<8>::bitset<8>
PUBLIC	??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z ; std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$max@_K@std@@YAAEB_KAEB_K0@Z			; std::max<unsigned __int64>
PUBLIC	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z		; std::_Deallocate<16>
PUBLIC	??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::operator()
PUBLIC	??0<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEAA@PEBV12@AEBD1@Z ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::<lambda_1>
PUBLIC	??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Max_limit@_J@std@@YA_JXZ			; std::_Max_limit<__int64>
PUBLIC	??$min@_K@std@@YAAEB_KAEB_K0@Z			; std::min<unsigned __int64>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>
PUBLIC	??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1> >
PUBLIC	??$move@AEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@std@@YA$$QEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@0@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DD@Z@AEAV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@20@QEBA?AV30@DD@Z@@Z ; std::move<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> &>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$construct_at@D$$V@std@@YAPEADQEAD@Z		; std::construct_at<char>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char *>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * const &>
PUBLIC	??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YA_K_K@Z		; std::_Get_size_of_n<1>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	_TI3?AVbad_array_new_length@std@@
PUBLIC	_CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@OGIIGPAB@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@MIFAIHL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_0CK@FLHINDMP@the?5returned?5size?5can?8t?5be?5smal@ ; `string'
PUBLIC	??_C@_0GC@BPEFGDOI@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@OCAJPBKK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1FI@BDLMIMCF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@ ; `string'
PUBLIC	??_C@_0DI@EDFJJLDD@the?5returned?5size?5can?8t?5be?5grea@ ; `string'
PUBLIC	??_C@_1HE@LCDIHDIF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	__real@3ee4f8b588e368f1
PUBLIC	__real@408f400000000000
PUBLIC	__real@43e0000000000000
PUBLIC	__real@bff0000000000000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp__CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	memcpy:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	__std_exception_copy:PROC
EXTRN	__std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UEAAPEAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UEAAPEAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSize:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN8
	DD	imagerel $LN8+143
	DD	imagerel $unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBDH@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+89
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1exception@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??1exception@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?what@exception@std@@UEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+56
	DD	imagerel $unwind$?what@exception@std@@UEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@AEAA@QEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$??0bad_alloc@std@@AEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_alloc@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_alloc@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_alloc@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_alloc@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1bad_array_new_length@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+25
	DD	imagerel $unwind$??1bad_array_new_length@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_bad_array_new_length@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?_Throw_bad_array_new_length@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD imagerel $LN21
	DD	imagerel $LN21+404
	DD	imagerel $unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+104
	DD	imagerel $unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen_string@std@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$?_Xlen_string@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+176
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+80
	DD	imagerel $unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+93
	DD	imagerel $unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+32
	DD	imagerel $unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+56
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+136
	DD	imagerel $unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+112
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD imagerel $LN4
	DD	imagerel $LN4+110
	DD	imagerel $unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+70
	DD	imagerel $unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+177
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z
$pdata$?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+211
	DD	imagerel $unwind$?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z
$pdata$?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ
$pdata$?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z DD imagerel $LN56
	DD	imagerel $LN56+2937
	DD	imagerel $unwind$?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z
$pdata$?os_reserve_memory@d_std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?os_reserve_memory@d_std@@YA_K_K@Z
$pdata$?os_commit_memory@d_std@@YAX_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?os_commit_memory@d_std@@YAX_K0@Z
$pdata$?os_decommit_memory@d_std@@YAX_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?os_decommit_memory@d_std@@YAX_K0@Z
$pdata$?os_release_memory@d_std@@YAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?os_release_memory@d_std@@YAX_K@Z
$pdata$?os_debug_print@d_std@@YAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$?os_debug_print@d_std@@YAXPEBD@Z
$pdata$?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ DD imagerel $LN5
	DD	imagerel $LN5+215
	DD	imagerel $unwind$?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ
$pdata$?os_debug_print@d_std@@YAXUd_string@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+335
	DD	imagerel $unwind$?os_debug_print@d_std@@YAXUd_string@1@@Z
$pdata$?is_debugger_present@d_std@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+36
	DD	imagerel $unwind$?is_debugger_present@d_std@@YA_NXZ
$pdata$?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+372
	DD	imagerel $unwind$?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z
$pdata$?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z DD imagerel $LN4
	DD	imagerel $LN4+204
	DD	imagerel $unwind$?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z
$pdata$?close_file@d_std@@YA_NUFile@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$?close_file@d_std@@YA_NUFile@1@@Z
$pdata$?release@Memory_Arena@d_std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$?release@Memory_Arena@d_std@@QEAAXXZ
$pdata$?reset@Memory_Arena@d_std@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$?reset@Memory_Arena@d_std@@QEAAXXZ
$pdata$?allocate@Memory_Arena@d_std@@QEAA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+74
	DD	imagerel $unwind$?allocate@Memory_Arena@d_std@@QEAA_K_K@Z
$pdata$?deallocate@Memory_Arena@d_std@@QEAAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+70
	DD	imagerel $unwind$?deallocate@Memory_Arena@d_std@@QEAAX_K@Z
$pdata$?push@Memory_Arena@d_std@@QEAA_K_K@Z DD imagerel $LN8
	DD	imagerel $LN8+356
	DD	imagerel $unwind$?push@Memory_Arena@d_std@@QEAA_K_K@Z
$pdata$?pop_to@Memory_Arena@d_std@@QEAAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+211
	DD	imagerel $unwind$?pop_to@Memory_Arena@d_std@@QEAAX_K@Z
$pdata$?pop_all@Memory_Arena@d_std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?pop_all@Memory_Arena@d_std@@QEAAXXZ
$pdata$?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ
$pdata$?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+115
	DD	imagerel $unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z
$pdata$?murmur3_32@d_std@@YAIPEAXII@Z DD imagerel $LN9
	DD	imagerel $LN9+382
	DD	imagerel $unwind$?murmur3_32@d_std@@YAIPEAXII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z DD imagerel $LN55
	DD	imagerel $LN55+2079
	DD	imagerel $unwind$?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+56
	DD	imagerel $unwind$??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?os_debug_printf@d_std@@YAXPEBDZZ DD imagerel $LN5
	DD	imagerel $LN5+187
	DD	imagerel $unwind$?os_debug_printf@d_std@@YAXPEBDZZ
$pdata$?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z DD imagerel $LN29
	DD	imagerel $LN29+728
	DD	imagerel $unwind$?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z
$pdata$?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z DD imagerel $LN34
	DD	imagerel $LN34+940
	DD	imagerel $unwind$?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z
$pdata$main DD	imagerel $LN33
	DD	imagerel $LN33+2627
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$bitset@$07@std@@QEAA@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+67
	DD	imagerel $unwind$??0?$bitset@$07@std@@QEAA@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z DD imagerel $LN5
	DD	imagerel $LN5+143
	DD	imagerel $unwind$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA DD imagerel ?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA
	DD	imagerel ?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+180
	DD	imagerel $unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+35
	DD	imagerel $unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$max@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+71
	DD	imagerel $unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+87
	DD	imagerel $unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z DD imagerel $LN8
	DD	imagerel $LN8+173
	DD	imagerel $unwind$??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z DD imagerel $LN23
	DD	imagerel $LN23+445
	DD	imagerel $unwind$??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD imagerel $LN7
	DD	imagerel $LN7+184
	DD	imagerel $unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+128
	DD	imagerel $unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+141
	DD	imagerel $unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Max_limit@_J@std@@YA_JXZ DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$??$_Max_limit@_J@std@@YA_JXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$min@_K@std@@YAAEB_KAEB_K0@Z DD imagerel $LN6
	DD	imagerel $LN6+71
	DD	imagerel $unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD imagerel $LN3
	DD	imagerel $LN3+99
	DD	imagerel $unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+83
	DD	imagerel $unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z DD imagerel $LN6
	DD	imagerel $LN6+397
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD imagerel $LN5
	DD	imagerel $LN5+79
	DD	imagerel $unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@D$$V@std@@YAPEADQEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$??$construct_at@D$$V@std@@YAPEADQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+65
	DD	imagerel $unwind$??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD imagerel $LN13
	DD	imagerel $LN13+259
	DD	imagerel $unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z
pdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+18
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3ee4f8b588e368f1
CONST	SEGMENT
__real@3ee4f8b588e368f1 DQ 03ee4f8b588e368f1r	; 1e-05
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 01H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	imagerel ??_R3bad_alloc@std@@8
	DD	imagerel ??_R4bad_alloc@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD imagerel ??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD imagerel ??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD imagerel ??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD imagerel ??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@bad_alloc@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 01H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	imagerel ??_R3bad_array_new_length@std@@8
	DD	imagerel ??_R4bad_array_new_length@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_1HE@LCDIHDIF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@
CONST	SEGMENT
??_C@_1HE@LCDIHDIF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@ DB '"'
	DB	00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'e'
	DB	00H, ' ', 00H, 'g', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 't', 00H
	DB	'e', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'a', 00H, 'n'
	DB	00H, ' ', 00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'p', 00H
	DB	'a', 00H, 's', 00H, 's', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@EDFJJLDD@the?5returned?5size?5can?8t?5be?5grea@
CONST	SEGMENT
??_C@_0DI@EDFJJLDD@the?5returned?5size?5can?8t?5be?5grea@ DB 'the returne'
	DB	'd size can''t be greater than the passed size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@BDLMIMCF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@
CONST	SEGMENT
??_C@_1FI@BDLMIMCF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@ DB '"'
	DB	00H, 't', 00H, 'h', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' '
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 'n', 00H, '''', 00H, 't', 00H, ' ', 00H, 'b', 00H, 'e'
	DB	00H, ' ', 00H, 's', 00H, 'm', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'e', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'a', 00H, 'n'
	DB	00H, ' ', 00H, '0', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@OCAJPBKK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@OCAJPBKK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '4', 00H, '1', 00H, '.', 00H, '3', 00H, '4', 00H, '1'
	DB	00H, '2', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@BPEFGDOI@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@BPEFGDOI@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'41.34120\include\xstring', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FLHINDMP@the?5returned?5size?5can?8t?5be?5smal@
CONST	SEGMENT
??_C@_0CK@FLHINDMP@the?5returned?5size?5can?8t?5be?5smal@ DB 'the returne'
	DB	'd size can''t be smaller than 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@MIFAIHL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@MIFAIHL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '4', 00H, '1', 00H, '.', 00H, '3', 00H, '4', 00H, '1'
	DB	00H, '2', 00H, '0', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@OGIIGPAB@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@OGIIGPAB@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'41.34120\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24 DD 010H
	DD	imagerel ??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_alloc@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT _CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	imagerel _CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
_TI3?AVbad_array_new_length@std@@ DD 00H
	DD	imagerel ??1bad_array_new_length@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DQ FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DQ	FLAT:??_Ebad_array_new_length@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DQ FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DQ	FLAT:??_Ebad_alloc@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$00@std@@YA_K_K@Z DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$construct_at@D$$V@std@@YAPEADQEAD@Z DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$min@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Max_limit@_J@std@@YA_JXZ DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DB 060H
	DD	imagerel $ip2state$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z DD 010e19H
	DD	0420eH
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$max@_K@std@@YAAEB_KAEB_K0@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z DB 04H
	DB	00H
	DB	00H
	DB	'4'
	DB	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z DB 02H
	DB	0eH
	DD	imagerel ?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z DB 028H
	DD	imagerel $stateUnwindMap$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z
	DD	imagerel $ip2state$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z DD 031a11H
	DD	07016a21aH
	DD	06015H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$bitset@$07@std@@QEAA@_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	014H
	DD	0a29H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?os_debug_printf@d_std@@YAXPEBDZZ
	DD	026H
	DD	0a2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?os_debug_print@d_std@@YAXUd_string@1@@Z
	DD	016H
	DD	0137H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ
	DD	027H
	DD	0bdH
voltbl	ENDS
xdata	SEGMENT
$unwind$?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z DD 010e01H
	DD	0620eH
$unwind$?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z DD 011301H
	DD	06213H
$unwind$?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z DD 041d01H
	DD	017011dH
	DD	060157016H
$unwind$?os_reserve_memory@d_std@@YA_K_K@Z DD 010901H
	DD	06209H
$unwind$?os_commit_memory@d_std@@YAX_K0@Z DD 010e01H
	DD	0420eH
$unwind$?os_decommit_memory@d_std@@YAX_K0@Z DD 010e01H
	DD	0420eH
$unwind$?os_release_memory@d_std@@YAX_K@Z DD 010901H
	DD	04209H
$unwind$?os_debug_print@d_std@@YAXPEBD@Z DD 010901H
	DD	04209H
$unwind$?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ DD 042f19H
	DD	04f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$?os_debug_print@d_std@@YAXUd_string@1@@Z DD 021e19H
	DD	04b010cH
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$?is_debugger_present@d_std@@YA_NXZ DD 010401H
	DD	06204H
$unwind$?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z DD 011301H
	DD	0a213H
$unwind$?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z DD 011801H
	DD	08218H
$unwind$?close_file@d_std@@YA_NUFile@1@@Z DD 010901H
	DD	04209H
$unwind$?release@Memory_Arena@d_std@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?reset@Memory_Arena@d_std@@QEAAXXZ DD 010901H
	DD	06209H
$unwind$?allocate@Memory_Arena@d_std@@QEAA_K_K@Z DD 010e01H
	DD	0620eH
$unwind$?deallocate@Memory_Arena@d_std@@QEAAX_K@Z DD 010e01H
	DD	0620eH
$unwind$?push@Memory_Arena@d_std@@QEAA_K_K@Z DD 010e01H
	DD	0a20eH
$unwind$?pop_to@Memory_Arena@d_std@@QEAAX_K@Z DD 010e01H
	DD	0820eH
$unwind$?pop_all@Memory_Arena@d_std@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ DD 010401H
	DD	06204H
$unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z DD 010901H
	DD	06209H
$unwind$?murmur3_32@d_std@@YAIPEAXII@Z DD 011201H
	DD	08212H
$unwind$?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z DD 041d01H
	DD	013011dH
	DD	060157016H
$unwind$?os_debug_printf@d_std@@YAXPEBDZZ DD 032e19H
	DD	048011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z DD 011801H
	DD	06218H
$unwind$?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z DD 011801H
	DD	04218H
$unwind$main DD	041c19H
	DD	06d010aH
	DD	060027003H
	DD	imagerel __GSHandlerCheck
	DD	0358H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DB 060H
	DD	imagerel $ip2state$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z DD 011319H
	DD	04213H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 010919H
	DD	06209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen_string@std@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z DD 010e01H
	DD	0220eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_bad_array_new_length@std@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_array_new_length@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_array_new_length@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_array_new_length@std@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_alloc@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@QEAA@AEBV01@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1bad_alloc@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_alloc@std@@AEAA@QEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?what@exception@std@@UEBAPEBDXZ DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1exception@std@@UEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBDH@Z DD 011001H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 0
_Count$ = 32
??$_Get_size_of_n@$00@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<1>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 0

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	mov	rax, QWORD PTR _Count$[rsp]

; 90   : }

	add	rsp, 24
	ret	0
??$_Get_size_of_n@$00@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Ptr_container$ = 48
_Ptr$ = 56
_Block_size$ = 64
_Bytes$ = 96
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 151  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

$LN13:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 152  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

	mov	rax, QWORD PTR _Bytes$[rsp]
	add	rax, 47					; 0000002fH
	mov	QWORD PTR _Block_size$[rsp], rax

; 154  :     if (_Block_size <= _Bytes) {

	mov	rax, QWORD PTR _Bytes$[rsp]
	cmp	QWORD PTR _Block_size$[rsp], rax
	ja	SHORT $LN8@Allocate_m

; 155  :         _Throw_bad_array_new_length(); // add overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN8@Allocate_m:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

	mov	rcx, QWORD PTR _Block_size$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Allocate_m:

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	cmp	QWORD PTR _Ptr_container$[rsp], 0
	je	SHORT $LN9@Allocate_m
	jmp	SHORT $LN10@Allocate_m
$LN9@Allocate_m:
$LN7@Allocate_m:
	lea	rax, OFFSET FLAT:$SG72652
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:$SG72653
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 159				; 0000009fH
	lea	rdx, OFFSET FLAT:$SG72654
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@Allocate_m
	int	3
	xor	eax, eax
$LN12@Allocate_m:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 159				; 0000009fH
	lea	r8, OFFSET FLAT:$SG72655
	lea	rdx, OFFSET FLAT:$SG72656
	lea	rcx, OFFSET FLAT:$SG72657
	call	QWORD PTR __imp__invalid_parameter
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Allocate_m
$LN10@Allocate_m:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Allocate_m

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	rax, QWORD PTR _Ptr_container$[rsp]
	add	rax, 47					; 0000002fH
	and	rax, -32				; ffffffffffffffe0H
	mov	QWORD PTR _Ptr$[rsp], rax

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rcx+rax], rdx

; 162  : 
; 163  : #ifdef _DEBUG
; 164  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

	mov	eax, 8
	imul	rax, rax, -2
	mov	rcx, QWORD PTR _Ptr$[rsp]
	mov	rdx, -361700864190383366		; fafafafafafafafaH
	mov	QWORD PTR [rcx+rax], rdx

; 165  : #endif // defined(_DEBUG)
; 166  :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]
$LN11@Allocate_m:

; 167  : }

	add	rsp, 88					; 00000058H
	ret	0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
tv76 = 32
$T1 = 40
_Location$ = 64
<_Args_0>$ = 72
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 389  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 390  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rsp]
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z ; std::forward<std::_Container_base12 *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv76[rsp], rax
	mov	rdx, QWORD PTR tv76[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 391  : }

	add	rsp, 56					; 00000038H
	ret	0
??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1536 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1537 : }

	ret	0
??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1558 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1559 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1560 : }

	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z
_TEXT	SEGMENT
$T1 = 32
_Location$ = 64
<_Args_0>$ = 72
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z PROC ; std::construct_at<char *,char * const &>, COMDAT

; 389  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 390  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	rdx, QWORD PTR _Location$[rsp]
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR $T1[rsp]

; 391  : }

	add	rsp, 56					; 00000038H
	ret	0
??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ENDP ; std::construct_at<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1536 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1537 : }

	ret	0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char *>, COMDAT

; 1558 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1559 :     return __builtin_addressof(_Val);

	mov	rax, QWORD PTR _Val$[rsp]

; 1560 : }

	ret	0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$construct_at@D$$V@std@@YAPEADQEAD@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
_Location$ = 64
??$construct_at@D$$V@std@@YAPEADQEAD@Z PROC		; std::construct_at<char>, COMDAT

; 389  :     noexcept(::new(static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H

; 390  :     _MSVC_CONSTEXPR return ::new (static_cast<void*>(_Location)) _Ty(_STD forward<_Types>(_Args)...);

	mov	QWORD PTR $T1[rsp], 1
	mov	rdx, QWORD PTR _Location$[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T2[rsp], rax
	mov	rdi, QWORD PTR $T2[rsp]
	xor	eax, eax
	mov	rcx, QWORD PTR $T1[rsp]
	rep stosb
	mov	rax, QWORD PTR $T2[rsp]

; 391  : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$construct_at@D$$V@std@@YAPEADQEAD@Z ENDP		; std::construct_at<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Count$ = 56
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2173 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2174 : #if _HAS_CXX23
; 2175 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2176 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2177 :         _Count                  = _Allocated;
; 2178 :         return _Ptr;
; 2179 :     } else
; 2180 : #endif // _HAS_CXX23
; 2181 :     {
; 2182 :         return _Al.allocate(_Count);

	mov	rax, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate

; 2183 :     }
; 2184 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 682  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 683  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 684  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 685  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@deallocate

; 686  :             _Al.deallocate(_Ptr, _Count);

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::deallocate
	npad	1

; 687  :         } else

	jmp	SHORT $LN3@deallocate
$LN2@deallocate:

; 688  : #endif // _HAS_CXX20
; 689  :         {
; 690  :             (void) _Al;
; 691  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 16
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1
$LN3@deallocate:

; 692  :         }
; 693  :     }

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$move@AEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@std@@YA$$QEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@0@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DD@Z@AEAV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@20@QEBA?AV30@DD@Z@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@std@@YA$$QEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@0@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DD@Z@AEAV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@20@QEBA?AV30@DD@Z@@Z PROC ; std::move<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> &>, COMDAT

; 1546 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1547 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, QWORD PTR _Arg$[rsp]

; 1548 : }

	ret	0
??$move@AEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@std@@YA$$QEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@0@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DD@Z@AEAV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@20@QEBA?AV30@DD@Z@@Z ENDP ; std::move<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z
_TEXT	SEGMENT
_My_data$ = 32
_Old_size$ = 40
_New_ptr$ = 48
_New_size$ = 56
_New_capacity$ = 64
_Old_capacity$ = 72
_Old_ptr$1 = 80
_Al$ = 88
_Raw_new$ = 96
this$ = 128
_Size_increase$ = 136
_Fn$ = 144
??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1> >, COMDAT

; 2999 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN6:
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 120				; 00000078H

; 3000 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3001 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3002 :         auto& _My_data            = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3003 :         const size_type _Old_size = _My_data._Mysize;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR _Old_size$[rsp], rax

; 3004 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	rax, QWORD PTR _Old_size$[rsp]
	cmp	rax, QWORD PTR _Size_increase$[rsp]
	jae	SHORT $LN2@Reallocate

; 3005 :             _Xlen_string(); // result too long

	call	?_Xlen_string@std@@YAXXZ		; std::_Xlen_string
	npad	1
$LN2@Reallocate:

; 3006 :         }
; 3007 : 
; 3008 :         const size_type _New_size     = _Old_size + _Size_increase;

	mov	rax, QWORD PTR _Size_increase$[rsp]
	mov	rcx, QWORD PTR _Old_size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR _New_size$[rsp], rax

; 3009 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR _Old_capacity$[rsp], rax

; 3010 :         size_type _New_capacity       = _Calculate_growth(_New_size);

	mov	rdx, QWORD PTR _New_size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
	mov	QWORD PTR _New_capacity$[rsp], rax

; 3011 :         auto& _Al                     = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$[rsp], rax

; 3012 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

	lea	rdx, QWORD PTR _New_capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
	mov	QWORD PTR _New_ptr$[rsp], rax

; 3013 : 
; 3014 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all

; 3015 :         _ASAN_STRING_REMOVE(*this);
; 3016 :         _My_data._Mysize      = _New_size;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3017 :         _My_data._Myres       = _New_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_capacity$[rsp]
	mov	QWORD PTR [rax+32], rcx

; 3018 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Raw_new$[rsp], rax

; 3019 :         if (_Old_capacity > _Small_string_capacity) {

	cmp	QWORD PTR _Old_capacity$[rsp], 15
	jbe	SHORT $LN3@Reallocate

; 3020 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Old_ptr$1[rsp], rax

; 3021 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

	mov	rcx, QWORD PTR _Old_ptr$1[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1>::operator()

; 3022 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

	mov	r8, QWORD PTR _Old_capacity$[rsp]
	mov	rdx, QWORD PTR _Old_ptr$1[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3023 :             _My_data._Bx._Ptr = _New_ptr;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 3024 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3025 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	r9, QWORD PTR _Old_size$[rsp]
	mov	r8, rax
	mov	rdx, QWORD PTR _Raw_new$[rsp]
	lea	rcx, QWORD PTR _Fn$[rsp]
	call	??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1>::operator()

; 3026 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	lea	rdx, QWORD PTR _New_ptr$[rsp]
	mov	rcx, rax
	call	??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ; std::_Construct_in_place<char *,char * const &>
	npad	1
$LN4@Reallocate:

; 3027 :         }
; 3028 : 
; 3029 :         _ASAN_STRING_CREATE(*this);
; 3030 :         return *this;

	mov	rax, QWORD PTR this$[rsp]
$LN5@Reallocate:

; 3031 :     }

	add	rsp, 120				; 00000078H
	ret	0
??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z
_TEXT	SEGMENT
this$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1>::operator(), COMDAT

; 2390 :                     _STATIC_CALL_OPERATOR { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR _Old_size$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _New_ptr$[rsp]
	call	?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ; std::_Char_traits<char,int>::copy
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??R<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV0?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@2@QEBA?AV12@DD@Z@@Z@QEBA@QEADQEBD0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z PROC ; std::_Allocate<16,std::_Default_allocate_traits>, COMDAT

; 194  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 195  :     // allocate _Bytes
; 196  :     if (_Bytes == 0) {

	cmp	QWORD PTR _Bytes$[rsp], 0
	jne	SHORT $LN2@Allocate

; 197  :         return nullptr;

	xor	eax, eax
	jmp	SHORT $LN1@Allocate
$LN2@Allocate:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@Allocate

; 202  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
	jmp	SHORT $LN1@Allocate
$LN3@Allocate:

; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN4@Allocate

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
	jmp	SHORT $LN1@Allocate
$LN4@Allocate:

; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ; std::_Default_allocate_traits::_Allocate
$LN1@Allocate:

; 226  :     }
; 227  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ENDP ; std::_Allocate<16,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z
_TEXT	SEGMENT
_Overflow_is_possible$ = 32
_Max_possible$1 = 40
_Count$ = 64
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

	mov	BYTE PTR _Overflow_is_possible$[rsp], 1

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	mov	QWORD PTR _Max_possible$1[rsp], rax

; 84   :         if (_Count > _Max_possible) {

	mov	rax, 1152921504606846975		; 0fffffffffffffffH
	cmp	QWORD PTR _Count$[rsp], rax
	jbe	SHORT $LN2@Get_size_o

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

	call	?_Throw_bad_array_new_length@std@@YAXXZ	; std::_Throw_bad_array_new_length
	npad	1
$LN2@Get_size_o:

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

	imul	rax, QWORD PTR _Count$[rsp], 16
$LN3@Get_size_o:

; 90   : }

	add	rsp, 56					; 00000038H
	ret	0
??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
_New_proxy$ = 32
$T1 = 40
this$ = 64
_Al$ = 72
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT

; 1183 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1184 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

	mov	edx, 1
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ; std::allocator<std::_Container_proxy>::allocate
	mov	rcx, rax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	mov	QWORD PTR _New_proxy$[rsp], rax

; 1185 :         _Construct_in_place(*_New_proxy, this);

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, QWORD PTR _New_proxy$[rsp]
	call	??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
	npad	1

; 1186 :         _Myproxy            = _New_proxy;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_proxy$[rsp]
	mov	QWORD PTR [rax], rcx

; 1187 :         _New_proxy->_Mycont = this;

	mov	rax, QWORD PTR _New_proxy$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], rcx

; 1188 :     }

	add	rsp, 56					; 00000038H
	ret	0
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$min@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$min@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::min<unsigned __int64>, COMDAT

; 95   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :     // return smaller of _Left and _Right
; 97   :     return _Right < _Left ? _Right : _Left;

	mov	rax, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@min
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@min
$LN3@min:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@min:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 98   : }

	add	rsp, 24
	ret	0
??$min@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::min<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$_Max_limit@_J@std@@YA_JXZ
_TEXT	SEGMENT
_Unsigned_max$1 = 0
??$_Max_limit@_J@std@@YA_JXZ PROC			; std::_Max_limit<__int64>, COMDAT

; 849  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

$LN4:
	sub	rsp, 24

; 850  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 851  :     if constexpr (is_signed_v<_Ty>) {
; 852  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

	mov	QWORD PTR _Unsigned_max$1[rsp], -1

; 853  :         return static_cast<_Ty>(_Unsigned_max >> 1);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 854  :     } else {
; 855  :         return static_cast<_Ty>(-1);
; 856  :     }
; 857  : }

	add	rsp, 24
	ret	0
??$_Max_limit@_J@std@@YA_JXZ ENDP			; std::_Max_limit<__int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z
_TEXT	SEGMENT
tv77 = 32
tv75 = 40
tv91 = 48
$T1 = 56
_Obj$ = 80
<_Args_0>$ = 88
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 396  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 397  : #if _HAS_CXX20
; 398  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Construct_

; 399  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z ; std::forward<std::_Container_base12 *>
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$construct_at@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAPEAU_Container_proxy@0@QEAU10@$$QEAPEAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *>
	npad	1

; 400  :     } else

	jmp	SHORT $LN3@Construct_
$LN2@Construct_:

; 401  : #endif // _HAS_CXX20
; 402  :     {
; 403  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@AEAU10@@Z ; std::addressof<std::_Container_proxy>
	mov	rdx, rax
	mov	ecx, 16
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@PEAU_Container_base12@std@@@std@@YA$$QEAPEAU_Container_base12@0@AEAPEAU10@@Z ; std::forward<std::_Container_base12 *>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv91[rsp], rax
	mov	rdx, QWORD PTR tv91[rsp]
	mov	rcx, QWORD PTR $T1[rsp]
	call	??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
	npad	1
$LN3@Construct_:

; 404  :     }
; 405  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Construct_in_place@U_Container_proxy@std@@PEAU_Container_base12@2@@std@@YAXAEAU_Container_proxy@0@$$QEAPEAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 36   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 37   : }

	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPEAU_Container_proxy@0@PEAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z
_TEXT	SEGMENT
tv77 = 32
tv75 = 40
$T1 = 48
_Obj$ = 80
<_Args_0>$ = 88
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 396  :     is_nothrow_constructible_v<_Ty, _Types...>) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 397  : #if _HAS_CXX20
; 398  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Construct_

; 399  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	QWORD PTR tv77[rsp], rax
	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	QWORD PTR tv75[rsp], rax
	mov	rdx, QWORD PTR tv77[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	??$construct_at@PEADAEBQEAD@std@@YAPEAPEADQEAPEADAEBQEAD@Z ; std::construct_at<char *,char * const &>
	npad	1

; 400  :     } else

	jmp	SHORT $LN3@Construct_
$LN2@Construct_:

; 401  : #endif // _HAS_CXX20
; 402  :     {
; 403  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

	mov	rcx, QWORD PTR _Obj$[rsp]
	call	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ; std::addressof<char *>
	mov	rdx, rax
	mov	ecx, 8
	call	??2@YAPEAX_KPEAX@Z			; operator new
	mov	QWORD PTR $T1[rsp], rax
	mov	rcx, QWORD PTR <_Args_0>$[rsp]
	call	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ; std::forward<char * const &>
	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rcx], rax
$LN3@Construct_:

; 404  :     }
; 405  : }

	add	rsp, 72					; 00000048H
	ret	0
??$_Construct_in_place@PEADAEBQEAD@std@@YAXAEAPEADAEBQEAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z
_TEXT	SEGMENT
_Idx$1 = 32
_Fancy_ptr$ = 40
_Ptr$2 = 48
_Al$ = 80
_Capacity$ = 88
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 804  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 805  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 806  :         ++_Capacity; // Take null terminator into consideration

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	inc	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 807  : 
; 808  :         pointer _Fancy_ptr = nullptr;

	mov	QWORD PTR _Fancy_ptr$[rsp], 0

; 809  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 810  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

	mov	rdx, QWORD PTR _Capacity$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPEADAEAV?$allocator@D@0@AEA_K@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
	mov	QWORD PTR _Fancy_ptr$[rsp], rax

; 811  :         } else {
; 812  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 813  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 814  :         }
; 815  : 
; 816  : #if _HAS_CXX20
; 817  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 818  :         // but likely more impactful to throughput.
; 819  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Allocate_f

; 820  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);

	mov	rcx, QWORD PTR _Fancy_ptr$[rsp]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Ptr$2[rsp], rax

; 821  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@Allocate_f
$LN2@Allocate_f:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@Allocate_f:
	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR _Idx$1[rsp], rax
	jae	SHORT $LN3@Allocate_f

; 822  :                 _STD construct_at(_Ptr + _Idx);

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR _Ptr$2[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, rax
	call	??$construct_at@D$$V@std@@YAPEADQEAD@Z	; std::construct_at<char>
	npad	1

; 823  :             }

	jmp	SHORT $LN2@Allocate_f
$LN3@Allocate_f:
$LN5@Allocate_f:

; 824  :         }
; 825  : #endif // _HAS_CXX20
; 826  :         --_Capacity;

	mov	rax, QWORD PTR _Capacity$[rsp]
	mov	rax, QWORD PTR [rax]
	dec	rax
	mov	rcx, QWORD PTR _Capacity$[rsp]
	mov	QWORD PTR [rcx], rax

; 827  :         return _Fancy_ptr;

	mov	rax, QWORD PTR _Fancy_ptr$[rsp]

; 828  :     }

	add	rsp, 72					; 00000048H
	ret	0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPEADAEAV?$allocator@D@1@AEA_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1099 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1100 :     // deallocate a plain pointer using an allocator
; 1101 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1102 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1103 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

	mov	r8d, 1
	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@2@QEAU_Container_proxy@2@_K@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
	npad	1

; 1104 :     } else {
; 1105 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1106 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1107 :     }
; 1108 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z
_TEXT	SEGMENT
$T1 = 48
_Result_size$ = 56
_Result_as_size_type$ = 64
_Arg_size$ = 72
_Arg_ptr$ = 80
tv89 = 88
this$ = 112
_New_size$ = 120
_Op$ = 128
??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >, COMDAT

; 2386 :         (_CRT_GUARDOVERFLOW const size_type _New_size, _Operation _Op) {

$LN23:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2387 :         if (_Mypair._Myval2._Myres < _New_size) {

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	cmp	QWORD PTR [rax+32], rcx
	jae	SHORT $LN14@Resize_and

; 2388 :             _Reallocate_grow_by(_New_size - _Mypair._Myval2._Mysize,

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	rcx, QWORD PTR _New_size$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	movzx	r8d, BYTE PTR $T1[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	??$_Reallocate_grow_by@V<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@3@QEBA?AV23@DD@Z@@Z@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_1>@?4???$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@01@QEAAX0V2?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >'::`5'::<lambda_1> >
	npad	1

; 2389 :                 [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size)
; 2390 :                     _STATIC_CALL_OPERATOR { _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1); });
; 2391 :         } else {

	jmp	SHORT $LN15@Resize_and
$LN14@Resize_and:

; 2392 :             _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 2393 :             _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+24], rcx
$LN15@Resize_and:

; 2394 :         }
; 2395 : 
; 2396 :         auto _Arg_ptr                   = _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	mov	QWORD PTR _Arg_ptr$[rsp], rax

; 2397 :         auto _Arg_size                  = _New_size;

	mov	rax, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR _Arg_size$[rsp], rax

; 2398 :         const auto _Result_size         = _STD move(_Op)(_Arg_ptr, _Arg_size);

	mov	rcx, QWORD PTR _Op$[rsp]
	call	??$move@AEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@std@@YA$$QEAV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@0@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DD@Z@AEAV1?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@20@QEBA?AV30@DD@Z@@Z ; std::move<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> &>
	mov	QWORD PTR tv89[rsp], rax
	mov	r8, QWORD PTR _Arg_size$[rsp]
	mov	rdx, QWORD PTR _Arg_ptr$[rsp]
	mov	rcx, QWORD PTR tv89[rsp]
	call	??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::operator()
	mov	QWORD PTR _Result_size$[rsp], rax

; 2399 :         const auto _Result_as_size_type = static_cast<size_type>(_Result_size);

	mov	rax, QWORD PTR _Result_size$[rsp]
	mov	QWORD PTR _Result_as_size_type$[rsp], rax
$LN4@Resize_and:

; 2400 : #if _CONTAINER_DEBUG_LEVEL > 0
; 2401 :         _STL_VERIFY(_Result_size >= 0, "the returned size can't be smaller than 0");

	cmp	QWORD PTR _Result_size$[rsp], 0
	jb	SHORT $LN16@Resize_and
	jmp	SHORT $LN17@Resize_and
$LN16@Resize_and:
$LN7@Resize_and:
	lea	rax, OFFSET FLAT:??_C@_0CK@FLHINDMP@the?5returned?5size?5can?8t?5be?5smal@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 2401				; 00000961H
	lea	rdx, OFFSET FLAT:??_C@_0GC@BPEFGDOI@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN21@Resize_and
	int	3
	xor	eax, eax
$LN21@Resize_and:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 2401				; 00000961H
	lea	r8, OFFSET FLAT:??_C@_1ME@OCAJPBKK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1FI@BDLMIMCF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@
	call	QWORD PTR __imp__invalid_parameter
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Resize_and
$LN17@Resize_and:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN4@Resize_and
$LN10@Resize_and:

; 2402 :         _STL_VERIFY(_Result_as_size_type <= _New_size, "the returned size can't be greater than the passed size");

	mov	rax, QWORD PTR _New_size$[rsp]
	cmp	QWORD PTR _Result_as_size_type$[rsp], rax
	ja	SHORT $LN18@Resize_and
	jmp	SHORT $LN19@Resize_and
$LN18@Resize_and:
$LN13@Resize_and:
	lea	rax, OFFSET FLAT:??_C@_0DI@EDFJJLDD@the?5returned?5size?5can?8t?5be?5grea@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 2402				; 00000962H
	lea	rdx, OFFSET FLAT:??_C@_0GC@BPEFGDOI@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN22@Resize_and
	int	3
	xor	eax, eax
$LN22@Resize_and:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 2402				; 00000962H
	lea	r8, OFFSET FLAT:??_C@_1ME@OCAJPBKK@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1HE@LCDIHDIF@?$AA?$CC?$AAt?$AAh?$AAe?$AA?5?$AAr?$AAe?$AAt?$AAu?$AAr?$AAn?$AAe?$AAd?$AA?5?$AAs@
	call	QWORD PTR __imp__invalid_parameter
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN13@Resize_and
$LN19@Resize_and:
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN10@Resize_and

; 2403 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 2404 :         _Eos(_Result_as_size_type);

	mov	rdx, QWORD PTR _Result_as_size_type$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
	npad	1

; 2405 :     }

	add	rsp, 104				; 00000068H
	ret	0
??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\bitset
;	COMDAT ??0<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEAA@PEBV12@AEBD1@Z
_TEXT	SEGMENT
this$ = 8
_This$ = 16
___Elem0$ = 24
___Elem1$ = 32
??0<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEAA@PEBV12@AEBD1@Z PROC ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::<lambda_1>, COMDAT

; 359  :         _Str._Resize_and_overwrite(_Bits, [this, _Elem0, _Elem1](_Elem* _Buf, size_t _Len) {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 360  : #if _USE_STD_VECTOR_ALGORITHMS
; 361  :             constexpr size_t _Bitset_vector_threshold = 32;
; 362  :             if constexpr (_Bits >= _Bitset_vector_threshold && is_integral_v<_Elem> && sizeof(_Elem) <= 2) {
; 363  :                 if (!_Is_constant_evaluated()) {
; 364  :                     if constexpr (sizeof(_Elem) == 1) {
; 365  :                         __std_bitset_to_string_1(reinterpret_cast<char*>(_Buf), _Array, _Len, static_cast<char>(_Elem0),
; 366  :                             static_cast<char>(_Elem1));
; 367  :                     } else {
; 368  :                         _STL_INTERNAL_STATIC_ASSERT(sizeof(_Elem) == 2);
; 369  :                         __std_bitset_to_string_2(reinterpret_cast<wchar_t*>(_Buf), _Array, _Len,
; 370  :                             static_cast<wchar_t>(_Elem0), static_cast<wchar_t>(_Elem1));
; 371  :                     }
; 372  :                     return _Len;
; 373  :                 }
; 374  :             }
; 375  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 376  : 
; 377  :             for (size_t _Pos = 0; _Pos < _Len; ++_Pos) {
; 378  :                 _Buf[_Pos] = _Subscript(_Len - 1 - _Pos) ? _Elem1 : _Elem0;
; 379  :             }
; 380  :             return _Len;
; 381  :         });

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _This$[rsp]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ___Elem0$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+8], cl
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR ___Elem1$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax+9], cl
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEAA@PEBV12@AEBD1@Z ENDP ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::<lambda_1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\bitset
;	COMDAT ??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z
_TEXT	SEGMENT
tv80 = 32
_Pos$1 = 40
tv75 = 48
_Bitset_vector_threshold$ = 56
this$ = 80
_Buf$ = 88
_Len$ = 96
??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z PROC ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::operator(), COMDAT

; 359  :         _Str._Resize_and_overwrite(_Bits, [this, _Elem0, _Elem1](_Elem* _Buf, size_t _Len) {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 360  : #if _USE_STD_VECTOR_ALGORITHMS
; 361  :             constexpr size_t _Bitset_vector_threshold = 32;

	mov	QWORD PTR _Bitset_vector_threshold$[rsp], 32 ; 00000020H

; 362  :             if constexpr (_Bits >= _Bitset_vector_threshold && is_integral_v<_Elem> && sizeof(_Elem) <= 2) {
; 363  :                 if (!_Is_constant_evaluated()) {
; 364  :                     if constexpr (sizeof(_Elem) == 1) {
; 365  :                         __std_bitset_to_string_1(reinterpret_cast<char*>(_Buf), _Array, _Len, static_cast<char>(_Elem0),
; 366  :                             static_cast<char>(_Elem1));
; 367  :                     } else {
; 368  :                         _STL_INTERNAL_STATIC_ASSERT(sizeof(_Elem) == 2);
; 369  :                         __std_bitset_to_string_2(reinterpret_cast<wchar_t*>(_Buf), _Array, _Len,
; 370  :                             static_cast<wchar_t>(_Elem0), static_cast<wchar_t>(_Elem1));
; 371  :                     }
; 372  :                     return _Len;
; 373  :                 }
; 374  :             }
; 375  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 376  : 
; 377  :             for (size_t _Pos = 0; _Pos < _Len; ++_Pos) {

	mov	QWORD PTR _Pos$1[rsp], 0
	jmp	SHORT $LN4@operator
$LN2@operator:
	mov	rax, QWORD PTR _Pos$1[rsp]
	inc	rax
	mov	QWORD PTR _Pos$1[rsp], rax
$LN4@operator:
	mov	rax, QWORD PTR _Len$[rsp]
	cmp	QWORD PTR _Pos$1[rsp], rax
	jae	SHORT $LN3@operator

; 378  :                 _Buf[_Pos] = _Subscript(_Len - 1 - _Pos) ? _Elem1 : _Elem0;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv75[rsp], rax
	mov	rax, QWORD PTR _Len$[rsp]
	dec	rax
	sub	rax, QWORD PTR _Pos$1[rsp]
	mov	rdx, rax
	mov	rcx, QWORD PTR tv75[rsp]
	call	?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z ; std::bitset<8>::_Subscript
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@operator
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+9]
	mov	BYTE PTR tv80[rsp], al
	jmp	SHORT $LN7@operator
$LN6@operator:
	mov	rax, QWORD PTR this$[rsp]
	movzx	eax, BYTE PTR [rax+8]
	mov	BYTE PTR tv80[rsp], al
$LN7@operator:
	mov	rax, QWORD PTR _Pos$1[rsp]
	mov	rcx, QWORD PTR _Buf$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	ecx, BYTE PTR tv80[rsp]
	mov	BYTE PTR [rax], cl

; 379  :             }

	jmp	SHORT $LN2@operator
$LN3@operator:

; 380  :             return _Len;

	mov	rax, QWORD PTR _Len$[rsp]

; 381  :         });

	add	rsp, 72					; 00000048H
	ret	0
??R<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEBA@PEAD_K@Z ENDP ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Bytes$ = 56
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z PROC		; std::_Deallocate<16>, COMDAT

; 230  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 231  :     // deallocate storage allocated by _Allocate
; 232  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 233  :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Deallocate

; 234  :         ::operator delete(_Ptr);

	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX@Z				; operator delete
	npad	1

; 235  :         return;

	jmp	SHORT $LN1@Deallocate
$LN2@Deallocate:

; 236  :     }
; 237  : #endif // _HAS_CXX20
; 238  : 
; 239  : #ifdef __cpp_aligned_new
; 240  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 241  :         size_t _Passed_align = _Align;
; 242  : #if defined(_M_IX86) || defined(_M_X64)
; 243  :         if (_Bytes >= _Big_allocation_threshold) {
; 244  :             // boost the alignment of big allocations to help autovectorization
; 245  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 246  :         }
; 247  : #endif // defined(_M_IX86) || defined(_M_X64)
; 248  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 249  :     } else
; 250  : #endif // defined(__cpp_aligned_new)
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) {

	cmp	QWORD PTR _Bytes$[rsp], 4096		; 00001000H
	jb	SHORT $LN3@Deallocate

; 254  :             // boost the alignment of big allocations to help autovectorization
; 255  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

	lea	rdx, QWORD PTR _Bytes$[rsp]
	lea	rcx, QWORD PTR _Ptr$[rsp]
	call	?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ; std::_Adjust_manually_vector_aligned
	npad	1
$LN3@Deallocate:

; 256  :         }
; 257  : #endif // defined(_M_IX86) || defined(_M_X64)
; 258  :         ::operator delete(_Ptr, _Bytes);

	mov	rdx, QWORD PTR _Bytes$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN1@Deallocate:

; 259  :     }
; 260  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z ENDP		; std::_Deallocate<16>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$max@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
tv65 = 0
$T1 = 8
_Left$ = 32
_Right$ = 40
??$max@_K@std@@YAAEB_KAEB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT

; 72   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 73   :     // return larger of _Left and _Right
; 74   :     return _Left < _Right ? _Right : _Left;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR [rcx]
	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN3@max
	mov	rax, QWORD PTR _Right$[rsp]
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@max
$LN3@max:
	mov	rax, QWORD PTR _Left$[rsp]
	mov	QWORD PTR tv65[rsp], rax
$LN4@max:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR $T1[rsp], rax
	mov	rax, QWORD PTR $T1[rsp]

; 75   : }

	add	rsp, 24
	ret	0
??$max@_K@std@@YAAEB_KAEB_K0@Z ENDP			; std::max<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z
_TEXT	SEGMENT
_Obj$ = 8
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z PROC	; std::_Destroy_in_place<char *>, COMDAT

; 289  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

	ret	0
??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ENDP	; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

	mov	QWORD PTR [rsp+8], rcx

; 36   :     return _Ptr;

	mov	rax, QWORD PTR _Ptr$[rsp]

; 37   : }

	ret	0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$ = 56
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 1495 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

$LN4:
	mov	BYTE PTR [rsp+16], dl
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0?$allocator@D@std@@QEAA@XZ		; std::allocator<char>::allocator<char>
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
	npad	1
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT

; 942  :     constexpr allocator(const allocator<_Other>&) noexcept {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z
_TEXT	SEGMENT
_Al$ = 48
_Ptr$ = 56
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1111 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1112 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1113 :     using _Ty = typename _Alloc::value_type;
; 1114 :     _Ptr->~_Ty();
; 1115 :     _STD _Deallocate_plain(_Al, _Ptr);

	mov	rdx, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
	npad	1

; 1116 : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 952  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 953  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 954  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$0BA@@std@@YA_K_K@Z	; std::_Get_size_of_n<16>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 955  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 946  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN4@deallocate:

; 947  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rsp], 0
	jne	SHORT $LN10@deallocate
	cmp	QWORD PTR _Count$[rsp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 947				; 000003b3H
	lea	rdx, OFFSET FLAT:??_C@_0GC@OGIIGPAB@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
	xor	eax, eax
$LN12@deallocate:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 947				; 000003b3H
	lea	r8, OFFSET FLAT:??_C@_1ME@MIFAIHL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	QWORD PTR __imp__invalid_parameter
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@deallocate
$LN9@deallocate:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@deallocate

; 948  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 949  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	imul	rax, QWORD PTR _Count$[rsp], 16
	mov	rdx, rax
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 950  :     }

	add	rsp, 56					; 00000038H
	ret	0
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXQEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\bitset
;	COMDAT ??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z
_TEXT	SEGMENT
$T1 = 32
tv65 = 40
$T2 = 48
$T3 = 64
this$ = 112
__$ReturnUdt$ = 120
_Elem0$ = 128
_Elem1$ = 136
??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z PROC ; std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 356  :         const _Elem _Elem0 = static_cast<_Elem>('0'), const _Elem _Elem1 = static_cast<_Elem>('1')) const {

$LN5:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H
	mov	DWORD PTR $T1[rsp], 0

; 357  :         // convert bitset to string
; 358  :         basic_string<_Elem, _Tr, _Alloc> _Str;

	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv65[rsp], rax
	mov	eax, DWORD PTR $T1[rsp]
	or	eax, 1
	mov	DWORD PTR $T1[rsp], eax

; 359  :         _Str._Resize_and_overwrite(_Bits, [this, _Elem0, _Elem1](_Elem* _Buf, size_t _Len) {

	lea	r9, QWORD PTR _Elem1$[rsp]
	lea	r8, QWORD PTR _Elem0$[rsp]
	mov	rdx, QWORD PTR this$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@DD@Z@QEAA@PEBV12@AEBD1@Z ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1>::<lambda_1>
	lea	rcx, QWORD PTR $T2[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	r8, QWORD PTR $T2[rsp]
	mov	edx, 8
	mov	rcx, QWORD PTR __$ReturnUdt$[rsp]
	call	??$_Resize_and_overwrite@V<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@DD@Z@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KV<lambda_1>@?1???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@1@QEBA?AV01@DD@Z@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Resize_and_overwrite<`std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`2'::<lambda_1> >
	npad	1

; 360  : #if _USE_STD_VECTOR_ALGORITHMS
; 361  :             constexpr size_t _Bitset_vector_threshold = 32;
; 362  :             if constexpr (_Bits >= _Bitset_vector_threshold && is_integral_v<_Elem> && sizeof(_Elem) <= 2) {
; 363  :                 if (!_Is_constant_evaluated()) {
; 364  :                     if constexpr (sizeof(_Elem) == 1) {
; 365  :                         __std_bitset_to_string_1(reinterpret_cast<char*>(_Buf), _Array, _Len, static_cast<char>(_Elem0),
; 366  :                             static_cast<char>(_Elem1));
; 367  :                     } else {
; 368  :                         _STL_INTERNAL_STATIC_ASSERT(sizeof(_Elem) == 2);
; 369  :                         __std_bitset_to_string_2(reinterpret_cast<wchar_t*>(_Buf), _Array, _Len,
; 370  :                             static_cast<wchar_t>(_Elem0), static_cast<wchar_t>(_Elem1));
; 371  :                     }
; 372  :                     return _Len;
; 373  :                 }
; 374  :             }
; 375  : #endif // _USE_STD_VECTOR_ALGORITHMS
; 376  : 
; 377  :             for (size_t _Pos = 0; _Pos < _Len; ++_Pos) {
; 378  :                 _Buf[_Pos] = _Subscript(_Len - 1 - _Pos) ? _Elem1 : _Elem0;
; 379  :             }
; 380  :             return _Len;
; 381  :         });
; 382  :         return _Str;

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]

; 383  :     }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
	int	3
??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z ENDP ; std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
tv65 = 40
$T2 = 48
$T3 = 64
this$ = 112
__$ReturnUdt$ = 120
_Elem0$ = 128
_Elem1$ = 136
?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA PROC ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN4@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z@4HA ENDP ; `std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\bitset
;	COMDAT ??0?$bitset@$07@std@@QEAA@_K@Z
_TEXT	SEGMENT
tv68 = 0
this$ = 32
_Val$ = 40
??0?$bitset@$07@std@@QEAA@_K@Z PROC			; std::bitset<8>::bitset<8>, COMDAT

; 109  :     constexpr bitset(unsigned long long _Val) noexcept : _Array{static_cast<_Ty>(_Need_mask ? _Val & _Mask : _Val)} {}

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24
	xor	eax, eax
	cmp	eax, 1
	je	SHORT $LN3@bitset
	mov	rax, QWORD PTR _Val$[rsp]
	and	rax, 255				; 000000ffH
	mov	QWORD PTR tv68[rsp], rax
	jmp	SHORT $LN4@bitset
$LN3@bitset:
	mov	rax, QWORD PTR _Val$[rsp]
	mov	QWORD PTR tv68[rsp], rax
$LN4@bitset:
	mov	rax, QWORD PTR this$[rsp]
	mov	ecx, DWORD PTR tv68[rsp]
	mov	DWORD PTR [rax], ecx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 24
	ret	0
??0?$bitset@$07@std@@QEAA@_K@Z ENDP			; std::bitset<8>::bitset<8>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\bitset
;	COMDAT ?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z
_TEXT	SEGMENT
tv72 = 0
tv84 = 4
tv65 = 8
this$ = 32
_Pos$ = 40
?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z PROC		; std::bitset<8>::_Subscript, COMDAT

; 89   :     constexpr bool _Subscript(size_t _Pos) const noexcept {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 90   :         return (_Array[_Pos / _Bitsperword] & (_Ty{1} << _Pos % _Bitsperword)) != 0;

	xor	edx, edx
	mov	rax, QWORD PTR _Pos$[rsp]
	mov	ecx, 32					; 00000020H
	div	rcx
	mov	QWORD PTR tv65[rsp], rax
	xor	edx, edx
	mov	rax, QWORD PTR _Pos$[rsp]
	mov	ecx, 32					; 00000020H
	div	rcx
	mov	rax, rdx
	mov	ecx, 1
	mov	DWORD PTR tv84[rsp], ecx
	movzx	ecx, al
	mov	eax, DWORD PTR tv84[rsp]
	shl	eax, cl
	mov	rcx, QWORD PTR this$[rsp]
	mov	rdx, QWORD PTR tv65[rsp]
	mov	ecx, DWORD PTR [rcx+rdx*4]
	and	ecx, eax
	mov	eax, ecx
	test	eax, eax
	je	SHORT $LN3@Subscript
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN4@Subscript
$LN3@Subscript:
	mov	DWORD PTR tv72[rsp], 0
$LN4@Subscript:
	movzx	eax, BYTE PTR tv72[rsp]

; 91   :     }

	add	rsp, 24
	ret	0
?_Subscript@?$bitset@$07@std@@AEBA_N_K@Z ENDP		; std::bitset<8>::_Subscript
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\hw2\main.cpp
_TEXT	SEGMENT
mod$1 = 48
w$2 = 49
d$3 = 50
reg$4 = 51
r_m$5 = 52
w$6 = 53
i$7 = 56
it$ = 64
disp_high$8 = 72
disp_low$9 = 73
base_arena$ = 80
data_high$10 = 88
data_low$11 = 89
displacement$12 = 92
displacement$13 = 96
reg$14 = 100
success$ = 101
data$15 = 104
data$16 = 108
source_string$17 = 112
dest_string$18 = 128
binary_op_code$19 = 144
dest_reg$20 = 152
tv401 = 168
test_file$ = 176
test_file_contents$ = 192
$T21 = 208
$T22 = 224
$T23 = 240
$T24 = 256
$T25 = 272
$T26 = 288
$T27 = 304
$T28 = 320
$T29 = 336
$T30 = 352
$T31 = 368
$T32 = 384
$T33 = 400
$T34 = 416
$T35 = 432
$T36 = 448
$T37 = 464
$T38 = 480
$T39 = 496
$T40 = 512
$T41 = 528
$T42 = 544
$T43 = 560
$T44 = 576
$T45 = 592
$T46 = 608
$T47 = 624
$T48 = 640
$T49 = 656
$T50 = 672
$T51 = 688
$T52 = 704
$T53 = 720
$T54 = 736
$T55 = 752
$T56 = 768
$T57 = 784
$T58 = 800
$T59 = 816
__$ArrayPad$ = 856
main	PROC

; 149  : int main(){

$LN33:
	push	rsi
	push	rdi
	sub	rsp, 872				; 00000368H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 150  : 
; 151  :     // Init
; 152  :     Memory_Arena* base_arena = make_arena();

	call	?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ ; d_std::make_arena
	mov	QWORD PTR base_arena$[rsp], rax

; 153  :     File test_file = open_file("..\\..\\computer_enhance\\perfaware\\part1\\listing_0039_more_movs", "r"); 

	lea	r8, OFFSET FLAT:$SG70427
	lea	rdx, OFFSET FLAT:$SG70428
	lea	rcx, QWORD PTR $T40[rsp]
	call	?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z ; d_std::open_file
	lea	rcx, QWORD PTR test_file$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 154  :     d_string test_file_contents = read_file(base_arena, test_file, test_file.size);

	lea	rax, QWORD PTR $T21[rsp]
	lea	rcx, QWORD PTR test_file$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	mov	r9d, DWORD PTR test_file$[rsp+8]
	lea	r8, QWORD PTR $T21[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T41[rsp]
	call	?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z ; d_std::read_file
	lea	rcx, QWORD PTR test_file_contents$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 155  : 
; 156  :     // Decode
; 157  :     char* it = test_file_contents.string;

	mov	rax, QWORD PTR test_file_contents$[rsp]
	mov	QWORD PTR it$[rsp], rax

; 158  :     for(int i = 0; i < test_file_contents.size; i++, it++){

	mov	DWORD PTR i$7[rsp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax
	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
$LN4@main:
	mov	eax, DWORD PTR test_file_contents$[rsp+8]
	cmp	DWORD PTR i$7[rsp], eax
	jae	$LN3@main

; 159  :         // MOV
; 160  :         // Register - To - Register
; 161  :         if((*it & 0b11111000) == 0b10001000){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 248				; 000000f8H
	cmp	eax, 136				; 00000088H
	jne	$LN5@main

; 162  :             u8 d = (*it & 0b00000010) >> 1;

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 2
	sar	eax, 1
	mov	BYTE PTR d$3[rsp], al

; 163  :             u8 w = *it & 0b00000001;

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 1
	mov	BYTE PTR w$2[rsp], al

; 164  :             it++, i++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax

; 165  :             u8 mod = (*it & 0b11000000) >> 6; 

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	sar	eax, 6
	mov	BYTE PTR mod$1[rsp], al

; 166  :             u8 reg  = (*it & 0b00111000) >> 3; 

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 56					; 00000038H
	sar	eax, 3
	mov	BYTE PTR reg$4[rsp], al

; 167  :             u8 r_m  = *it & 0b00000111; 

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 7
	mov	BYTE PTR r_m$5[rsp], al

; 168  :             printf("mov ");

	lea	rcx, OFFSET FLAT:$SG70431
	call	printf
	npad	1

; 169  :             d_string dest_string; 
; 170  :             d_string source_string; 
; 171  :             if(mod == 0b00){  // Memory, no displacement

	movzx	eax, BYTE PTR mod$1[rsp]
	test	eax, eax
	jne	$LN7@main

; 172  : 
; 173  :                 if(d == 0){

	movzx	eax, BYTE PTR d$3[rsp]
	test	eax, eax
	jne	$LN9@main

; 174  :                     source_string = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T42[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T22[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T22[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 175  :                     dest_string   = decode_effective_address_calculation(base_arena, mod, r_m, 0);

	mov	WORD PTR [rsp+32], 0
	movzx	r9d, BYTE PTR r_m$5[rsp]
	movzx	r8d, BYTE PTR mod$1[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T43[rsp]
	call	?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ; decode_effective_address_calculation
	lea	rcx, QWORD PTR $T23[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T23[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	jmp	$LN10@main
$LN9@main:

; 176  : 
; 177  :                 } else if (d == 1){

	movzx	eax, BYTE PTR d$3[rsp]
	cmp	eax, 1
	jne	$LN10@main

; 178  :                     dest_string   = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T44[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T24[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T24[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 179  :                     source_string = decode_effective_address_calculation(base_arena, mod, r_m, 0);

	mov	WORD PTR [rsp+32], 0
	movzx	r9d, BYTE PTR r_m$5[rsp]
	movzx	r8d, BYTE PTR mod$1[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T45[rsp]
	call	?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ; decode_effective_address_calculation
	lea	rcx, QWORD PTR $T25[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T25[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN10@main:

; 180  :                 }

	jmp	$LN8@main
$LN7@main:

; 181  : 
; 182  :             } else if(mod == 0b01){  // Memory, 8bit displacement

	movzx	eax, BYTE PTR mod$1[rsp]
	cmp	eax, 1
	jne	$LN12@main

; 183  : 
; 184  :                 u16 displacement = 0;

	xor	eax, eax
	mov	WORD PTR displacement$12[rsp], ax

; 185  : 
; 186  :                 it++, i++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax

; 187  :                 displacement = *it;

	mov	rax, QWORD PTR it$[rsp]
	movsx	ax, BYTE PTR [rax]
	mov	WORD PTR displacement$12[rsp], ax

; 188  : 
; 189  :                 if(d == 0){

	movzx	eax, BYTE PTR d$3[rsp]
	test	eax, eax
	jne	$LN14@main

; 190  :                     source_string = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T46[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T26[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T26[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 191  :                     dest_string = decode_effective_address_calculation(base_arena, mod, r_m, displacement);

	movzx	eax, WORD PTR displacement$12[rsp]
	mov	WORD PTR [rsp+32], ax
	movzx	r9d, BYTE PTR r_m$5[rsp]
	movzx	r8d, BYTE PTR mod$1[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T47[rsp]
	call	?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ; decode_effective_address_calculation
	lea	rcx, QWORD PTR $T27[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T27[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	jmp	$LN15@main
$LN14@main:

; 192  : 
; 193  :                 } else if (d == 1){

	movzx	eax, BYTE PTR d$3[rsp]
	cmp	eax, 1
	jne	$LN15@main

; 194  :                     dest_string   = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T48[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T28[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T28[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 195  :                     source_string = decode_effective_address_calculation(base_arena, mod, r_m, displacement);

	movzx	eax, WORD PTR displacement$12[rsp]
	mov	WORD PTR [rsp+32], ax
	movzx	r9d, BYTE PTR r_m$5[rsp]
	movzx	r8d, BYTE PTR mod$1[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T49[rsp]
	call	?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ; decode_effective_address_calculation
	lea	rcx, QWORD PTR $T29[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T29[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN15@main:

; 196  :                     
; 197  :                 }

	jmp	$LN8@main
$LN12@main:

; 198  : 
; 199  :             } else if(mod == 0b10){  // Memory, 16bit displacement

	movzx	eax, BYTE PTR mod$1[rsp]
	cmp	eax, 2
	jne	$LN17@main

; 200  : 
; 201  :                 u16 displacement = 0;

	xor	eax, eax
	mov	WORD PTR displacement$13[rsp], ax

; 202  :                 u8 disp_low  = 0;

	mov	BYTE PTR disp_low$9[rsp], 0

; 203  :                 u8 disp_high = 0;

	mov	BYTE PTR disp_high$8[rsp], 0

; 204  : 
; 205  :                 it++, i++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax

; 206  :                 disp_low = *it;

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR disp_low$9[rsp], al

; 207  : 
; 208  :                 it++, i++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax

; 209  :                 disp_high = *it;

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR disp_high$8[rsp], al

; 210  : 
; 211  :                 displacement = ((u16)disp_high << 8) | disp_low;

	movzx	eax, BYTE PTR disp_high$8[rsp]
	shl	eax, 8
	movzx	ecx, BYTE PTR disp_low$9[rsp]
	or	eax, ecx
	mov	WORD PTR displacement$13[rsp], ax

; 212  : 
; 213  :                 if(d == 0){

	movzx	eax, BYTE PTR d$3[rsp]
	test	eax, eax
	jne	$LN19@main

; 214  :                     source_string = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T50[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T30[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T30[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 215  :                     dest_string   = decode_effective_address_calculation(base_arena, mod, r_m, displacement);

	movzx	eax, WORD PTR displacement$13[rsp]
	mov	WORD PTR [rsp+32], ax
	movzx	r9d, BYTE PTR r_m$5[rsp]
	movzx	r8d, BYTE PTR mod$1[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T51[rsp]
	call	?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ; decode_effective_address_calculation
	lea	rcx, QWORD PTR $T31[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T31[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	jmp	$LN20@main
$LN19@main:

; 216  : 
; 217  :                 } else if (d == 1){

	movzx	eax, BYTE PTR d$3[rsp]
	cmp	eax, 1
	jne	$LN20@main

; 218  :                     dest_string   = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T52[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T32[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T32[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 219  :                     source_string = decode_effective_address_calculation(base_arena, mod, r_m, displacement);

	movzx	eax, WORD PTR displacement$13[rsp]
	mov	WORD PTR [rsp+32], ax
	movzx	r9d, BYTE PTR r_m$5[rsp]
	movzx	r8d, BYTE PTR mod$1[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T53[rsp]
	call	?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ; decode_effective_address_calculation
	lea	rcx, QWORD PTR $T33[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T33[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN20@main:

; 220  :                 }

	jmp	$LN8@main
$LN17@main:

; 221  : 
; 222  :             } else if(mod == 0b11){  // Reg to reg

	movzx	eax, BYTE PTR mod$1[rsp]
	cmp	eax, 3
	jne	$LN8@main

; 223  :                 if(d == 0){

	movzx	eax, BYTE PTR d$3[rsp]
	test	eax, eax
	jne	$LN23@main

; 224  :                     dest_string   = decode_reg(base_arena, r_m, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR r_m$5[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T54[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T34[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T34[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 225  :                     source_string = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T55[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T35[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T35[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	jmp	$LN8@main
$LN23@main:

; 226  :                 } else if (d == 1){

	movzx	eax, BYTE PTR d$3[rsp]
	cmp	eax, 1
	jne	$LN8@main

; 227  :                     dest_string   = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR reg$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T56[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T36[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_string$18[rsp]
	lea	rcx, QWORD PTR $T36[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 228  :                     source_string = decode_reg(base_arena, r_m, w);

	movzx	r9d, BYTE PTR w$2[rsp]
	movzx	r8d, BYTE PTR r_m$5[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T57[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T37[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_string$17[rsp]
	lea	rcx, QWORD PTR $T37[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN8@main:

; 229  :                 }
; 230  :             }
; 231  :             printf("%.*s, %.*s\n", dest_string.size, dest_string.string, source_string.size, source_string.string);

	mov	rax, QWORD PTR source_string$17[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR source_string$17[rsp+8]
	mov	r8, QWORD PTR dest_string$18[rsp]
	mov	edx, DWORD PTR dest_string$18[rsp+8]
	lea	rcx, OFFSET FLAT:$SG70451
	call	printf
	npad	1

; 232  :         }

	jmp	$LN6@main
$LN5@main:

; 233  :         else if((*it & 0b11110000) == 0b10110000){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 240				; 000000f0H
	cmp	eax, 176				; 000000b0H
	jne	$LN26@main

; 234  :             u8 w =     (*it & 0b00001000) >> 3;

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 8
	sar	eax, 3
	mov	BYTE PTR w$6[rsp], al

; 235  :             u8 reg  =  *it & 0b00000111; 

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 7
	mov	BYTE PTR reg$14[rsp], al

; 236  :             it++, i++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax

; 237  :             printf("mov ");

	lea	rcx, OFFSET FLAT:$SG70454
	call	printf
	npad	1

; 238  :             d_string dest_reg; 
; 239  :             dest_reg   = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$6[rsp]
	movzx	r8d, BYTE PTR reg$14[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T58[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T38[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_reg$20[rsp]
	lea	rcx, QWORD PTR $T38[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 240  :             if(w == 1){

	movzx	eax, BYTE PTR w$6[rsp]
	cmp	eax, 1
	jne	SHORT $LN28@main

; 241  :                 u8 data_low  = *it;

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR data_low$11[rsp], al

; 242  :                 it++, i++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
	mov	eax, DWORD PTR i$7[rsp]
	inc	eax
	mov	DWORD PTR i$7[rsp], eax

; 243  :                 u8 data_high = *it;

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR data_high$10[rsp], al

; 244  :                 u16 data = (((u16)data_high) << 8) | data_low; 

	movzx	eax, BYTE PTR data_high$10[rsp]
	shl	eax, 8
	movzx	ecx, BYTE PTR data_low$11[rsp]
	or	eax, ecx
	mov	WORD PTR data$15[rsp], ax

; 245  :                 printf("%.*s, %d\n", dest_reg.size, dest_reg.string, data);

	movzx	eax, WORD PTR data$15[rsp]
	mov	r9d, eax
	mov	r8, QWORD PTR dest_reg$20[rsp]
	mov	edx, DWORD PTR dest_reg$20[rsp+8]
	lea	rcx, OFFSET FLAT:$SG70457
	call	printf
	npad	1
	jmp	SHORT $LN29@main
$LN28@main:

; 246  :             } else if (w == 0) {

	movzx	eax, BYTE PTR w$6[rsp]
	test	eax, eax
	jne	SHORT $LN29@main

; 247  :                 u16 data = *it;

	mov	rax, QWORD PTR it$[rsp]
	movsx	ax, BYTE PTR [rax]
	mov	WORD PTR data$16[rsp], ax

; 248  :                 printf("%.*s, %d\n", dest_reg.size, dest_reg.string, data);

	movzx	eax, WORD PTR data$16[rsp]
	mov	r9d, eax
	mov	r8, QWORD PTR dest_reg$20[rsp]
	mov	edx, DWORD PTR dest_reg$20[rsp+8]
	lea	rcx, OFFSET FLAT:$SG70459
	call	printf
	npad	1
$LN29@main:

; 249  :             }
; 250  :         } else {

	jmp	SHORT $LN6@main
$LN26@main:

; 251  :             std::bitset<8>binary_op_code(*it);

	mov	rax, QWORD PTR it$[rsp]
	movsx	rax, BYTE PTR [rax]
	mov	rdx, rax
	lea	rcx, QWORD PTR binary_op_code$19[rsp]
	call	??0?$bitset@$07@std@@QEAA@_K@Z		; std::bitset<8>::bitset<8>
	npad	1

; 252  :             printf("Unrecognized Op Code! : %s\n", binary_op_code.to_string().c_str());

	mov	r9b, 49					; 00000031H
	mov	r8b, 48					; 00000030H
	lea	rdx, QWORD PTR $T59[rsp]
	lea	rcx, QWORD PTR binary_op_code$19[rsp]
	call	??$to_string@DU?$char_traits@D@std@@V?$allocator@D@2@@?$bitset@$07@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@DD@Z ; std::bitset<8>::to_string<char,std::char_traits<char>,std::allocator<char> >
	mov	QWORD PTR tv401[rsp], rax
	mov	rcx, QWORD PTR tv401[rsp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG70460
	call	printf
	lea	rcx, QWORD PTR $T59[rsp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
$LN6@main:

; 253  :         }
; 254  :     }

	jmp	$LN2@main
$LN3@main:

; 255  : 
; 256  :     // Destroy
; 257  :     bool success   = close_file(test_file);

	lea	rax, QWORD PTR $T39[rsp]
	lea	rcx, QWORD PTR test_file$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rcx, QWORD PTR $T39[rsp]
	call	?close_file@d_std@@YA_NUFile@1@@Z	; d_std::close_file
	mov	BYTE PTR success$[rsp], al

; 258  :     base_arena->release();

	mov	rcx, QWORD PTR base_arena$[rsp]
	call	?release@Memory_Arena@d_std@@QEAAXXZ	; d_std::Memory_Arena::release
	npad	1

; 259  : }

	xor	eax, eax
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 872				; 00000368H
	pop	rdi
	pop	rsi
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\hw2\main.cpp
_TEXT	SEGMENT
__$ReturnAddress$ = 48
arena$ = 56
reg$ = 64
w$ = 72
?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z PROC ; decode_reg

; 74   : d_string decode_reg(Memory_Arena* arena, u8 reg, u8 w){

$LN34:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 75   :     d_string reg_string;
; 76   :     reg_string.string = arena->allocate_array<char>(2);

	mov	edx, 2
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 77   :     reg_string.size = 2;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], 2

; 78   : 
; 79   :     if(reg == 0b000){

	movzx	eax, BYTE PTR reg$[rsp]
	test	eax, eax
	jne	SHORT $LN2@decode_reg

; 80   : 
; 81   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN4@decode_reg

; 82   :             reg_string.string[0] = 'A';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 65			; 00000041H

; 83   :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 84   :         } else {

	jmp	SHORT $LN5@decode_reg
$LN4@decode_reg:

; 85   :             reg_string.string[0] = 'A';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 65			; 00000041H

; 86   :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN5@decode_reg:

; 87   :         }

	jmp	$LN3@decode_reg
$LN2@decode_reg:

; 88   : 
; 89   :     } else if(reg == 0b001){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 1
	jne	SHORT $LN6@decode_reg

; 90   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN8@decode_reg

; 91   :             reg_string.string[0] = 'C';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 67			; 00000043H

; 92   :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 93   :         } else {

	jmp	SHORT $LN9@decode_reg
$LN8@decode_reg:

; 94   :             reg_string.string[0] = 'C';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 67			; 00000043H

; 95   :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN9@decode_reg:

; 96   :         }

	jmp	$LN7@decode_reg
$LN6@decode_reg:

; 97   :     } else if(reg == 0b010){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 2
	jne	SHORT $LN10@decode_reg

; 98   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN12@decode_reg

; 99   :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 100  :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 101  :         } else {

	jmp	SHORT $LN13@decode_reg
$LN12@decode_reg:

; 102  :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 103  :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN13@decode_reg:

; 104  :         }

	jmp	$LN11@decode_reg
$LN10@decode_reg:

; 105  :     } else if(reg == 0b011){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 3
	jne	SHORT $LN14@decode_reg

; 106  :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN16@decode_reg

; 107  :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 108  :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 109  :         } else {

	jmp	SHORT $LN17@decode_reg
$LN16@decode_reg:

; 110  :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 111  :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN17@decode_reg:

; 112  :         }

	jmp	$LN15@decode_reg
$LN14@decode_reg:

; 113  :     } else if(reg == 0b100){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 4
	jne	SHORT $LN18@decode_reg

; 114  :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN20@decode_reg

; 115  :             reg_string.string[0] = 'A';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 65			; 00000041H

; 116  :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 117  :         } else {

	jmp	SHORT $LN21@decode_reg
$LN20@decode_reg:

; 118  :             reg_string.string[0] = 'S';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 83			; 00000053H

; 119  :             reg_string.string[1] = 'P';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 80			; 00000050H
$LN21@decode_reg:

; 120  :         }

	jmp	$LN19@decode_reg
$LN18@decode_reg:

; 121  :     } else if(reg == 0b101){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 5
	jne	SHORT $LN22@decode_reg

; 122  :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN24@decode_reg

; 123  :             reg_string.string[0] = 'C';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 67			; 00000043H

; 124  :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 125  :         } else {

	jmp	SHORT $LN25@decode_reg
$LN24@decode_reg:

; 126  :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 127  :             reg_string.string[1] = 'P';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 80			; 00000050H
$LN25@decode_reg:

; 128  :         }

	jmp	$LN23@decode_reg
$LN22@decode_reg:

; 129  :     } else if(reg == 0b110){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 6
	jne	SHORT $LN26@decode_reg

; 130  :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN28@decode_reg

; 131  :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 132  :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 133  :         } else {

	jmp	SHORT $LN29@decode_reg
$LN28@decode_reg:

; 134  :             reg_string.string[0] = 'S';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 83			; 00000053H

; 135  :             reg_string.string[1] = 'I';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 73			; 00000049H
$LN29@decode_reg:

; 136  :         }

	jmp	SHORT $LN27@decode_reg
$LN26@decode_reg:

; 137  :     } else if(reg == 0b111){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 7
	jne	SHORT $LN30@decode_reg

; 138  :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN31@decode_reg

; 139  :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 140  :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 141  :         } else {

	jmp	SHORT $LN32@decode_reg
$LN31@decode_reg:

; 142  :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 143  :             reg_string.string[1] = 'I';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 73			; 00000049H
$LN32@decode_reg:
$LN30@decode_reg:
$LN27@decode_reg:
$LN23@decode_reg:
$LN19@decode_reg:
$LN15@decode_reg:
$LN11@decode_reg:
$LN7@decode_reg:
$LN3@decode_reg:

; 144  :         }
; 145  :     }
; 146  :     return reg_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 147  : }

	add	rsp, 40					; 00000028H
	ret	0
?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ENDP ; decode_reg
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\hw2\main.cpp
_TEXT	SEGMENT
tv70 = 32
tv129 = 36
__$ReturnAddress$ = 64
arena$ = 72
mod$ = 80
r_m$ = 88
displacement$ = 96
?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z PROC ; decode_effective_address_calculation

; 9    : d_string decode_effective_address_calculation(Memory_Arena* arena, u8 mod, u8 r_m, u16 displacement){

$LN29:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 10   : 
; 11   :     d_string reg_string;
; 12   :     reg_string.string = arena->allocate_array<char>(25);

	mov	edx, 25
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 13   :     reg_string.size = 25;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], 25

; 14   : 
; 15   :     if(mod == 0b00){

	movzx	eax, BYTE PTR mod$[rsp]
	test	eax, eax
	jne	$LN6@decode_eff

; 16   :         switch(r_m){

	movzx	eax, BYTE PTR r_m$[rsp]
	mov	DWORD PTR tv70[rsp], eax
	cmp	DWORD PTR tv70[rsp], 7
	ja	$LN2@decode_eff
	movsxd	rax, DWORD PTR tv70[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN28@decode_eff[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN8@decode_eff:

; 17   :             case 0b000:
; 18   :                 sprintf(reg_string.string, "[BX + SI]");

	lea	rdx, OFFSET FLAT:$SG70189
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 19   :                 break;

	jmp	$LN2@decode_eff
$LN9@decode_eff:

; 20   :             case 0b001:
; 21   :                 sprintf(reg_string.string, "[BX + DI]");

	lea	rdx, OFFSET FLAT:$SG70191
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 22   :                 break;

	jmp	$LN2@decode_eff
$LN10@decode_eff:

; 23   :             case 0b010:
; 24   :                 sprintf(reg_string.string, "[BP + SI]");

	lea	rdx, OFFSET FLAT:$SG70193
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 25   :                 break;

	jmp	$LN2@decode_eff
$LN11@decode_eff:

; 26   :             case 0b011:
; 27   :                 sprintf(reg_string.string, "[BP + DI]");

	lea	rdx, OFFSET FLAT:$SG70195
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 28   :                 break;

	jmp	SHORT $LN2@decode_eff
$LN12@decode_eff:

; 29   :             case 0b100:
; 30   :                 sprintf(reg_string.string, "[SI]");

	lea	rdx, OFFSET FLAT:$SG70197
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 31   :                 break;

	jmp	SHORT $LN2@decode_eff
$LN13@decode_eff:

; 32   :             case 0b101:
; 33   :                 sprintf(reg_string.string, "[DI]");

	lea	rdx, OFFSET FLAT:$SG70199
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 34   :                 break;

	jmp	SHORT $LN2@decode_eff
$LN14@decode_eff:

; 35   :             case 0b110:
; 36   :                 sprintf(reg_string.string, "%d", r_m);

	movzx	eax, BYTE PTR r_m$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70201
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 37   :                 break;

	jmp	SHORT $LN2@decode_eff
$LN15@decode_eff:

; 38   :             case 0b111:
; 39   :                 sprintf(reg_string.string, "[BX]", r_m);

	movzx	eax, BYTE PTR r_m$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70203
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1
$LN2@decode_eff:

; 40   :                 break;
; 41   :         }
; 42   :     } else if(mod == 0b01 || mod == 0b10) {

	jmp	$LN7@decode_eff
$LN6@decode_eff:
	movzx	eax, BYTE PTR mod$[rsp]
	cmp	eax, 1
	je	SHORT $LN17@decode_eff
	movzx	eax, BYTE PTR mod$[rsp]
	cmp	eax, 2
	jne	$LN16@decode_eff
$LN17@decode_eff:

; 43   :         switch(r_m){

	movzx	eax, BYTE PTR r_m$[rsp]
	mov	DWORD PTR tv129[rsp], eax
	cmp	DWORD PTR tv129[rsp], 7
	ja	$LN4@decode_eff
	movsxd	rax, DWORD PTR tv129[rsp]
	lea	rcx, OFFSET FLAT:__ImageBase
	mov	eax, DWORD PTR $LN27@decode_eff[rcx+rax*4]
	add	rax, rcx
	jmp	rax
$LN18@decode_eff:

; 44   :             case 0b000:
; 45   :                 sprintf(reg_string.string, "[BX + SI + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70207
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 46   :                 break;

	jmp	$LN4@decode_eff
$LN19@decode_eff:

; 47   :             case 0b001:
; 48   :                 sprintf(reg_string.string, "[BX + DI + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70209
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 49   :                 break;

	jmp	$LN4@decode_eff
$LN20@decode_eff:

; 50   :             case 0b010:
; 51   :                 sprintf(reg_string.string, "[BP + SI + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70211
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 52   :                 break;

	jmp	$LN4@decode_eff
$LN21@decode_eff:

; 53   :             case 0b011:
; 54   :                 sprintf(reg_string.string, "[BP + DI + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70213
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 55   :                 break;

	jmp	SHORT $LN4@decode_eff
$LN22@decode_eff:

; 56   :             case 0b100:
; 57   :                 sprintf(reg_string.string, "[SI + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70215
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 58   :                 break;

	jmp	SHORT $LN4@decode_eff
$LN23@decode_eff:

; 59   :             case 0b101:
; 60   :                 sprintf(reg_string.string, "[DI + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70217
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 61   :                 break;

	jmp	SHORT $LN4@decode_eff
$LN24@decode_eff:

; 62   :             case 0b110:
; 63   :                 sprintf(reg_string.string, "[BP + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70219
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1

; 64   :                 break;

	jmp	SHORT $LN4@decode_eff
$LN25@decode_eff:

; 65   :             case 0b111:
; 66   :                 sprintf(reg_string.string, "[BX + %d]", displacement);

	movzx	eax, WORD PTR displacement$[rsp]
	mov	r8d, eax
	lea	rdx, OFFSET FLAT:$SG70221
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	sprintf
	npad	1
$LN4@decode_eff:
$LN16@decode_eff:
$LN7@decode_eff:

; 67   :                 break;
; 68   :         }
; 69   :     }
; 70   : 
; 71   :     return reg_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 72   : }

	add	rsp, 56					; 00000038H
	ret	0
	npad	3
$LN28@decode_eff:
	DD	$LN8@decode_eff
	DD	$LN9@decode_eff
	DD	$LN10@decode_eff
	DD	$LN11@decode_eff
	DD	$LN12@decode_eff
	DD	$LN13@decode_eff
	DD	$LN14@decode_eff
	DD	$LN15@decode_eff
$LN27@decode_eff:
	DD	$LN18@decode_eff
	DD	$LN19@decode_eff
	DD	$LN20@decode_eff
	DD	$LN21@decode_eff
	DD	$LN22@decode_eff
	DD	$LN23@decode_eff
	DD	$LN24@decode_eff
	DD	$LN25@decode_eff
?decode_effective_address_calculation@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EEG@Z ENDP ; decode_effective_address_calculation
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
$T1 = 32
va_args$ = 40
c_str$ = 48
__$ArrayPad$ = 560
lit_string$ = 592
?os_debug_printf@d_std@@YAXPEBDZZ PROC			; d_std::os_debug_printf

; 107  :     void __cdecl os_debug_printf(const char* lit_string, ...){

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 576				; 00000240H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 108  : 
; 109  :         // va_list
; 110  :         u_ptr va_args;
; 111  : 
; 112  :         // va_start
; 113  :         va_args = (u_ptr)(&lit_string + 1);

	lea	rax, QWORD PTR lit_string$[rsp+8]
	mov	QWORD PTR va_args$[rsp], rax

; 114  : 
; 115  :         char c_str[501] = {0}; 

	lea	rax, QWORD PTR c_str$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 501				; 000001f5H
	rep stosb

; 116  : 
; 117  :         _format_lit_string(c_str, 500, lit_string, va_args);

	mov	r9, QWORD PTR va_args$[rsp]
	mov	r8, QWORD PTR lit_string$[rsp]
	mov	dx, 500					; 000001f4H
	lea	rcx, QWORD PTR c_str$[rsp]
	call	?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z ; d_std::_format_lit_string
	npad	1

; 118  : 
; 119  :         c_str[500] = '\0';

	mov	eax, 1
	imul	rax, rax, 500				; 000001f4H
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 501			; 000001f5H
	jae	SHORT $LN3@os_debug_p
	jmp	SHORT $LN4@os_debug_p
$LN3@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN4@os_debug_p:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 120  : 
; 121  :         OutputDebugStringA(c_str);

	lea	rcx, QWORD PTR c_str$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1
$LN2@os_debug_p:

; 122  : 
; 123  :         return;
; 124  : 
; 125  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 576				; 00000240H
	pop	rdi
	ret	0
?os_debug_printf@d_std@@YAXPEBDZZ ENDP			; d_std::os_debug_printf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.h
;	COMDAT ??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z
_TEXT	SEGMENT
tv65 = 32
this$ = 64
array$ = 72
??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z PROC ; d_std::Memory_Arena::deallocate_array<char>, COMDAT

; 94   :         inline void deallocate_array(t* array){

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 95   : 
; 96   : 
; 97   :             switch (this->type)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@deallocate
	jmp	SHORT $LN2@deallocate
$LN4@deallocate:

; 98   :             {
; 99   :             case Memory_Arena_Type_Linear:
; 100  : 
; 101  :                 this->deallocate((u_ptr)array);

	mov	rdx, QWORD PTR array$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?deallocate@Memory_Arena@d_std@@QEAAX_K@Z ; d_std::Memory_Arena::deallocate
	npad	1
$LN2@deallocate:

; 102  :                 break;
; 103  :             
; 104  :             }
; 105  : 
; 106  :         }

	add	rsp, 56					; 00000038H
	ret	0
??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ENDP ; d_std::Memory_Arena::deallocate_array<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
return_string_size$ = 0
size_limit_reached$ = 4
capacity$ = 8
temp$1 = 16
placement_ptr$2 = 24
it$ = 32
temp$3 = 40
placement_ptr$4 = 48
tv87 = 56
i$5 = 60
double_input$6 = 64
input_string_iterator$7 = 72
placement_ptr$8 = 80
placement_ptr$9 = 88
integer_part$10 = 96
number$11 = 104
decimal_part$12 = 112
c_str$13 = 120
d_str$14 = 128
return_string$ = 176
return_string_max_size$ = 184
lit_string$ = 192
va_args$ = 200
?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z PROC	; d_std::_format_lit_string

; 55   :     void __cdecl _format_lit_string(char* return_string, u16 return_string_max_size, const char* lit_string, u_ptr va_args){

$LN55:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H

; 56   : 
; 57   :         // it iterates through the original string
; 58   :         const char* it = lit_string;

	mov	rax, QWORD PTR lit_string$[rsp]
	mov	QWORD PTR it$[rsp], rax

; 59   : 
; 60   :         u16 return_string_size = 0;

	xor	eax, eax
	mov	WORD PTR return_string_size$[rsp], ax

; 61   :         u16 capacity = return_string_max_size;

	movzx	eax, WORD PTR return_string_max_size$[rsp]
	mov	WORD PTR capacity$[rsp], ax

; 62   :         bool size_limit_reached = false;

	mov	BYTE PTR size_limit_reached$[rsp], 0
$LN2@format_lit:

; 63   : 
; 64   :         while( *it != '\0' && size_limit_reached == false){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@format_lit
	movzx	eax, BYTE PTR size_limit_reached$[rsp]
	test	eax, eax
	jne	$LN3@format_lit
$LN4@format_lit:

; 65   : 
; 66   :             while( *it != '%' && *it != '\0'){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN5@format_lit
	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN5@format_lit

; 67   :                 return_string[return_string_size] = *it;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	mov	rdx, QWORD PTR it$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl

; 68   :                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 69   :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 70   :                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN31@format_lit

; 71   :                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 72   :                     break;

	jmp	SHORT $LN5@format_lit
$LN31@format_lit:

; 73   :                 }
; 74   :             }

	jmp	SHORT $LN4@format_lit
$LN5@format_lit:

; 75   :             if ( *it == '%' ) {

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN32@format_lit

; 76   :                 if ( *(it+1) != '\0' ){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	$LN33@format_lit

; 77   :                     
; 78   :                     // Switch based on argument type
; 79   :                     switch(*(it+1)){

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR tv87[rsp], al
	cmp	BYTE PTR tv87[rsp], 36			; 00000024H
	je	$LN39@format_lit
	cmp	BYTE PTR tv87[rsp], 102			; 00000066H
	je	$LN41@format_lit
	cmp	BYTE PTR tv87[rsp], 115			; 00000073H
	je	$LN37@format_lit
	cmp	BYTE PTR tv87[rsp], 117			; 00000075H
	je	SHORT $LN34@format_lit
	jmp	$LN6@format_lit
$LN34@format_lit:

; 80   : 
; 81   :                         // Unsigned int
; 82   :                         case('u'):
; 83   :                         {
; 84   :                             u64 number = *(u64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR number$11[rsp], rax

; 85   :                             va_args += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 86   : 
; 87   :                             char* placement_ptr = return_string + return_string_size - 1;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	lea	rax, QWORD PTR [rcx+rax-1]
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 88   : 
; 89   :                             // Guarantee one spot. What if "number" is 0?
; 90   :                             u64 temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 91   :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 92   :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 93   :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN35@format_lit

; 94   :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 95   :                                 break;

	jmp	$LN6@format_lit
$LN35@format_lit:

; 96   :                             }
; 97   :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 98   : 
; 99   :                             // Find the reset of the space this number will take up in the string
; 100  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN10@format_lit
$LN8@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
$LN10@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN9@format_lit

; 101  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 102  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 103  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN36@format_lit

; 104  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 105  :                                     break;

	jmp	SHORT $LN9@format_lit
$LN36@format_lit:

; 106  :                                 }
; 107  :                             }

	jmp	SHORT $LN8@format_lit
$LN9@format_lit:

; 108  : 
; 109  :                             // Insert the numbers from smallest (right) to largest (left)
; 110  :                             temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 111  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 112  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 113  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 114  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN13@format_lit
$LN11@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax
$LN13@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN12@format_lit

; 115  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 116  :                             }

	jmp	SHORT $LN11@format_lit
$LN12@format_lit:

; 117  : 
; 118  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 119  :                         }
; 120  :                         break;

	jmp	$LN6@format_lit
$LN37@format_lit:

; 121  : 
; 122  :                         // C string
; 123  :                         case('s'):
; 124  :                         {
; 125  :                             char* c_str = *(char**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR c_str$13[rsp], rax

; 126  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 127  : 
; 128  :                             char* placement_ptr = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 129  : 
; 130  :                             char* input_string_iterator = (char*)c_str;

	mov	rax, QWORD PTR c_str$13[rsp]
	mov	QWORD PTR input_string_iterator$7[rsp], rax
$LN14@format_lit:

; 131  : 
; 132  :                             while(*input_string_iterator != '\0'){

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN15@format_lit

; 133  : 
; 134  :                                 // Set char in output string 
; 135  :                                 *placement_ptr = *input_string_iterator;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	mov	rcx, QWORD PTR input_string_iterator$7[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 136  : 
; 137  :                                 // Advance Iterators
; 138  :                                 input_string_iterator++;

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	inc	rax
	mov	QWORD PTR input_string_iterator$7[rsp], rax

; 139  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 140  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 141  : 
; 142  :                                 // Possibly allocate more memory
; 143  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN38@format_lit

; 144  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 145  :                                     break;

	jmp	SHORT $LN15@format_lit
$LN38@format_lit:

; 146  :                                 }
; 147  :                             }

	jmp	SHORT $LN14@format_lit
$LN15@format_lit:

; 148  : 
; 149  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 150  :                         }
; 151  :                         break;

	jmp	$LN6@format_lit
$LN39@format_lit:

; 152  : 
; 153  :                         // d_std::d_string
; 154  :                         case('$'):
; 155  :                         {
; 156  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 157  :                             d_string d_str = **(d_string**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	lea	rcx, QWORD PTR d_str$14[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 158  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 159  : 
; 160  :                             char* placement_ptr = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 161  : 
; 162  :                             //char* input_string_iterator = (char*)d_str.string;
; 163  : 
; 164  :                             for(int i = 0; i < d_str.size; i++){

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN18@format_lit
$LN16@format_lit:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN18@format_lit:
	mov	eax, DWORD PTR d_str$14[rsp+8]
	cmp	DWORD PTR i$5[rsp], eax
	jae	SHORT $LN17@format_lit

; 165  : 
; 166  :                                 // Set char in output string 
; 167  :                                 *placement_ptr = d_str.string[i];

	movsxd	rax, DWORD PTR i$5[rsp]
	mov	rcx, QWORD PTR placement_ptr$9[rsp]
	mov	rdx, QWORD PTR d_str$14[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al

; 168  : 
; 169  :                                 // Advance Iterators
; 170  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$9[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 171  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 172  : 
; 173  :                                 // Possibly allocate more memory
; 174  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN40@format_lit

; 175  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 176  :                                     break;

	jmp	SHORT $LN17@format_lit
$LN40@format_lit:

; 177  :                                 }
; 178  :                             }

	jmp	SHORT $LN16@format_lit
$LN17@format_lit:

; 179  : 
; 180  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 181  :                         }
; 182  :                         break;

	jmp	$LN6@format_lit
$LN41@format_lit:

; 183  : 
; 184  :                         // d_std::d_string
; 185  :                         case('f'):
; 186  :                         {
; 187  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 188  :                             double double_input = *(f64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR double_input$6[rsp], xmm0

; 189  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 190  : 
; 191  :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN42@format_lit

; 192  :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 193  :                                 break;

	jmp	$LN6@format_lit
$LN42@format_lit:

; 194  :                             }
; 195  : 
; 196  :                             char* placement_ptr = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 197  : 
; 198  :                             // Check and possibly add sign bit
; 199  :                             if(double_input < 0){

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR double_input$6[rsp]
	jbe	SHORT $LN43@format_lit

; 200  : 
; 201  :                                 // Add negative char in output string
; 202  :                                 *placement_ptr = '-';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 203  : 
; 204  :                                 // Advance Iterators
; 205  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 206  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 207  : 
; 208  :                                 // Possibly allocate more memory
; 209  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN44@format_lit

; 210  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 211  :                                     break;

	jmp	$LN6@format_lit
$LN44@format_lit:

; 212  :                                 }
; 213  : 
; 214  :                                 double_input *= -1;

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	mulsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR double_input$6[rsp], xmm0
$LN43@format_lit:

; 215  : 
; 216  :                             }
; 217  : 
; 218  :                             u64 integer_part = (u64)double_input;

	xor	eax, eax
	movsd	xmm0, QWORD PTR double_input$6[rsp]
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN54@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN54@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN54@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR integer_part$10[rsp], rax

; 219  : 
; 220  :                             // Guarantee one spot. What if "number" is 0?
; 221  :                             u64 temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 222  :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 223  :                             // Possibly allocate more memory
; 224  :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN45@format_lit

; 225  :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 226  :                                 break;

	jmp	$LN6@format_lit
$LN45@format_lit:

; 227  :                             }
; 228  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 229  : 
; 230  :                             // Find the reset of the space this number will take up in the string
; 231  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN21@format_lit
$LN19@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN21@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN20@format_lit

; 232  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 233  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 234  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN46@format_lit

; 235  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 236  :                                     break;

	jmp	SHORT $LN20@format_lit
$LN46@format_lit:

; 237  :                                 }
; 238  :                             }

	jmp	SHORT $LN19@format_lit
$LN20@format_lit:

; 239  : 
; 240  :                             // Insert the numbers from smallest (right) to largest (left)
; 241  :                             temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 242  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 243  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 244  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 245  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN24@format_lit
$LN22@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN24@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN23@format_lit

; 246  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 247  :                             }

	jmp	SHORT $LN22@format_lit
$LN23@format_lit:

; 248  : 
; 249  :                             placement_ptr     = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 250  : 
; 251  :                             // Insert decimal place
; 252  :                             *placement_ptr = '.';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 253  : 
; 254  :                             // Advance Iterators
; 255  :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 256  :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 257  : 
; 258  :                             // Possibly allocate more memory
; 259  :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN47@format_lit

; 260  :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 261  :                                 break;

	jmp	$LN6@format_lit
$LN47@format_lit:

; 262  :                             }
; 263  : 
; 264  :                             u64 decimal_part = (((double_input + 0.00001 )- (float)integer_part) * 1000.);

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	addsd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	mov	rax, QWORD PTR integer_part$10[rsp]
	test	rax, rax
	jl	SHORT $LN52@format_lit
	cvtsi2ss xmm1, rax
	jmp	SHORT $LN53@format_lit
$LN52@format_lit:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
$LN53@format_lit:
	cvtss2sd xmm1, xmm1
	subsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN51@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN51@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN51@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR decimal_part$12[rsp], rax

; 265  : 
; 266  :                             // Guarantee one spot. What if "number" is 0?
; 267  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 268  :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 269  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 270  : 
; 271  :                             // Find the reset of the space this number will take up in the string
; 272  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN27@format_lit
$LN25@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN27@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN26@format_lit

; 273  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 274  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 275  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN48@format_lit

; 276  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 277  :                                     break;

	jmp	SHORT $LN26@format_lit
$LN48@format_lit:

; 278  :                                 }
; 279  :                             }

	jmp	SHORT $LN25@format_lit
$LN26@format_lit:

; 280  : 
; 281  :                             // Insert the numbers from smallest (right) to largest (left)
; 282  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 283  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 284  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 285  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 286  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN30@format_lit
$LN28@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN30@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN29@format_lit

; 287  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 288  :                             }

	jmp	SHORT $LN28@format_lit
$LN29@format_lit:

; 289  : 
; 290  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
$LN6@format_lit:
$LN33@format_lit:

; 291  :                         }
; 292  :                         break;
; 293  :                     }
; 294  :                 }
; 295  :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 296  :                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN49@format_lit

; 297  :                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 298  :                     break;

	jmp	SHORT $LN3@format_lit
$LN49@format_lit:
$LN32@format_lit:

; 299  :                 }
; 300  :             }
; 301  : 
; 302  :         }

	jmp	$LN2@format_lit
$LN3@format_lit:

; 303  : 
; 304  :         return;
; 305  : 
; 306  :     }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z ENDP	; d_std::_format_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.h
;	COMDAT ??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
nitems$ = 56
??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z PROC ; d_std::Memory_Arena::allocate_array<char>, COMDAT

; 87   :         inline t* allocate_array(u64 nitems){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 88   : 
; 89   :             return (t*)allocate(nitems * sizeof(t));

	mov	rdx, QWORD PTR nitems$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?allocate@Memory_Arena@d_std@@QEAA_K_K@Z ; d_std::Memory_Arena::allocate

; 90   : 
; 91   :         }

	add	rsp, 40					; 00000028H
	ret	0
??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ENDP ; d_std::Memory_Arena::allocate_array<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_hash.h
_TEXT	SEGMENT
h$ = 32
k$ = 36
i$1 = 40
key_u8$ = 48
i$2 = 56
key$ = 80
len$ = 88
seed$ = 96
?murmur3_32@d_std@@YAIPEAXII@Z PROC			; d_std::murmur3_32

; 18   :     u32 murmur3_32(void* key, u32 len, u32 seed = 0){

$LN9:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 19   :         u32 h = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR h$[rsp], eax

; 20   :         u32 k;
; 21   :         u8* key_u8 = (u8*)key;

	mov	rax, QWORD PTR key$[rsp]
	mov	QWORD PTR key_u8$[rsp], rax

; 22   : 
; 23   :         // For each 4 bytes in key_u8
; 24   :         for(size_t i = len >> 2; i != 0; i--){

	mov	eax, DWORD PTR len$[rsp]
	shr	eax, 2
	mov	eax, eax
	mov	QWORD PTR i$2[rsp], rax
	jmp	SHORT $LN4@murmur3_32
$LN2@murmur3_32:
	mov	rax, QWORD PTR i$2[rsp]
	dec	rax
	mov	QWORD PTR i$2[rsp], rax
$LN4@murmur3_32:
	cmp	QWORD PTR i$2[rsp], 0
	je	SHORT $LN3@murmur3_32

; 25   :             // Copy 4 bytes to k
; 26   :             memcpy(&k, key_u8, sizeof(u32));

	mov	r8d, 4
	mov	rdx, QWORD PTR key_u8$[rsp]
	lea	rcx, QWORD PTR k$[rsp]
	call	memcpy

; 27   :             // Move key_u8 to next 4 bytes
; 28   :             key_u8 += sizeof(u32);

	mov	rax, QWORD PTR key_u8$[rsp]
	add	rax, 4
	mov	QWORD PTR key_u8$[rsp], rax

; 29   :             h ^= murmur3_scramble_32(k);

	mov	ecx, DWORD PTR k$[rsp]
	call	?murmur3_scramble_32@d_std@@YAII@Z	; d_std::murmur3_scramble_32
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 30   :             h = (h << 13) | (h >> 19);

	mov	eax, DWORD PTR h$[rsp]
	shl	eax, 13
	mov	ecx, DWORD PTR h$[rsp]
	shr	ecx, 19
	or	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 31   :             h = h * 5 + 0xe6546b64;

	imul	eax, DWORD PTR h$[rsp], 5
	add	eax, -430675100				; e6546b64H
	mov	DWORD PTR h$[rsp], eax

; 32   :         }

	jmp	SHORT $LN2@murmur3_32
$LN3@murmur3_32:

; 33   : 
; 34   :         // Deal with the remaining bytes
; 35   :         k = 0;

	mov	DWORD PTR k$[rsp], 0

; 36   :         for(size_t i = len & 3; i != 0; i--){

	mov	eax, DWORD PTR len$[rsp]
	and	eax, 3
	mov	eax, eax
	mov	QWORD PTR i$1[rsp], rax
	jmp	SHORT $LN7@murmur3_32
$LN5@murmur3_32:
	mov	rax, QWORD PTR i$1[rsp]
	dec	rax
	mov	QWORD PTR i$1[rsp], rax
$LN7@murmur3_32:
	cmp	QWORD PTR i$1[rsp], 0
	je	SHORT $LN6@murmur3_32

; 37   :             k <<= 8;

	mov	eax, DWORD PTR k$[rsp]
	shl	eax, 8
	mov	DWORD PTR k$[rsp], eax

; 38   :             k |= key_u8[i - 1];

	mov	rax, QWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR key_u8$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax-1]
	mov	ecx, DWORD PTR k$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 39   :         }

	jmp	SHORT $LN5@murmur3_32
$LN6@murmur3_32:

; 40   : 
; 41   :         h ^= murmur3_scramble_32(k);

	mov	ecx, DWORD PTR k$[rsp]
	call	?murmur3_scramble_32@d_std@@YAII@Z	; d_std::murmur3_scramble_32
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 42   :         h ^= len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 43   :         h ^= h >> 16;

	mov	eax, DWORD PTR h$[rsp]
	shr	eax, 16
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 44   :         h *= 0x85ebca6b;

	imul	eax, DWORD PTR h$[rsp], -2048144789	; 85ebca6bH
	mov	DWORD PTR h$[rsp], eax

; 45   :         h ^= h >> 13;

	mov	eax, DWORD PTR h$[rsp]
	shr	eax, 13
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 46   :         h *= 0xc2b2ae35;

	imul	eax, DWORD PTR h$[rsp], -1028477387	; c2b2ae35H
	mov	DWORD PTR h$[rsp], eax

; 47   :         h ^= h >> 16;

	mov	eax, DWORD PTR h$[rsp]
	shr	eax, 16
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 48   :         return h;

	mov	eax, DWORD PTR h$[rsp]

; 49   :     }

	add	rsp, 72					; 00000048H
	ret	0
?murmur3_32@d_std@@YAIPEAXII@Z ENDP			; d_std::murmur3_32
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_hash.h
_TEXT	SEGMENT
key_4_bytes$ = 8
?murmur3_scramble_32@d_std@@YAII@Z PROC			; d_std::murmur3_scramble_32

; 11   :     static inline u32 murmur3_scramble_32(u32 key_4_bytes){

	mov	DWORD PTR [rsp+8], ecx

; 12   :         key_4_bytes *= 0xcc9e2d51;

	imul	eax, DWORD PTR key_4_bytes$[rsp], -862048943 ; cc9e2d51H
	mov	DWORD PTR key_4_bytes$[rsp], eax

; 13   :         key_4_bytes = (key_4_bytes << 15) | (key_4_bytes >> 17);

	mov	eax, DWORD PTR key_4_bytes$[rsp]
	shl	eax, 15
	mov	ecx, DWORD PTR key_4_bytes$[rsp]
	shr	ecx, 17
	or	eax, ecx
	mov	DWORD PTR key_4_bytes$[rsp], eax

; 14   :         key_4_bytes *= 0x1b873593;

	imul	eax, DWORD PTR key_4_bytes$[rsp], 461845907 ; 1b873593H
	mov	DWORD PTR key_4_bytes$[rsp], eax

; 15   :         return key_4_bytes;

	mov	eax, DWORD PTR key_4_bytes$[rsp]

; 16   :     }

	ret	0
?murmur3_scramble_32@d_std@@YAII@Z ENDP			; d_std::murmur3_scramble_32
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
arena$ = 32
memory$1 = 40
reserve_size$ = 64
?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z PROC	; d_std::make_arena

; 6    :     Memory_Arena* make_arena(u64 reserve_size) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 7    :         Memory_Arena* arena = nullptr;

	mov	QWORD PTR arena$[rsp], 0

; 8    : 
; 9    :         if(reserve_size > sizeof(Memory_Arena)){

	cmp	QWORD PTR reserve_size$[rsp], 32	; 00000020H
	jbe	SHORT $LN2@make_arena

; 10   :             u_ptr memory = d_reserve(reserve_size);

	mov	rcx, QWORD PTR reserve_size$[rsp]
	call	?os_reserve_memory@d_std@@YA_K_K@Z	; d_std::os_reserve_memory
	mov	QWORD PTR memory$1[rsp], rax

; 11   :             d_commit(memory, sizeof(Memory_Arena));

	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR memory$1[rsp]
	call	?os_commit_memory@d_std@@YAX_K0@Z	; d_std::os_commit_memory

; 12   :             arena = (Memory_Arena*) memory;

	mov	rax, QWORD PTR memory$1[rsp]
	mov	QWORD PTR arena$[rsp], rax

; 13   : 
; 14   :             arena->capacity = reserve_size;

	mov	rax, QWORD PTR arena$[rsp]
	mov	rcx, QWORD PTR reserve_size$[rsp]
	mov	QWORD PTR [rax], rcx

; 15   :             arena->position = sizeof(Memory_Arena);

	mov	rax, QWORD PTR arena$[rsp]
	mov	QWORD PTR [rax+8], 32			; 00000020H

; 16   :             arena->commit_position = sizeof(Memory_Arena);

	mov	rax, QWORD PTR arena$[rsp]
	mov	QWORD PTR [rax+16], 32			; 00000020H
$LN2@make_arena:

; 17   :         }
; 18   : 
; 19   :         return arena;

	mov	rax, QWORD PTR arena$[rsp]

; 20   :     }

	add	rsp, 56					; 00000038H
	ret	0
?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z ENDP	; d_std::make_arena
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
arena$ = 32
?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ PROC		; d_std::make_arena

; 22   :     Memory_Arena* make_arena() {

$LN3:
	sub	rsp, 56					; 00000038H

; 23   :         Memory_Arena* arena = make_arena(DEFAULT_ARENA_RESERVE_SIZE);

	mov	ecx, 671088640				; 28000000H
	call	?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z ; d_std::make_arena
	mov	QWORD PTR arena$[rsp], rax

; 24   :         return arena;

	mov	rax, QWORD PTR arena$[rsp]

; 25   :     }

	add	rsp, 56					; 00000038H
	ret	0
?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ ENDP		; d_std::make_arena
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
this$ = 48
?pop_all@Memory_Arena@d_std@@QEAAXXZ PROC		; d_std::Memory_Arena::pop_all

; 112  :     void Memory_Arena::pop_all(){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 113  : 
; 114  :         // Clear the arena, pop to the begining ( which is &arena + sizeof(Arena) )
; 115  :         pop_to(sizeof(Memory_Arena));

	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	call	?pop_to@Memory_Arena@d_std@@QEAAX_K@Z	; d_std::Memory_Arena::pop_to
	npad	1

; 116  : 
; 117  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pop_all@Memory_Arena@d_std@@QEAAXXZ ENDP		; d_std::Memory_Arena::pop_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
next_commit_position$1 = 32
aligned_position$2 = 40
tv74 = 48
decommission_size$3 = 56
this$ = 80
position$ = 88
?pop_to@Memory_Arena@d_std@@QEAAX_K@Z PROC		; d_std::Memory_Arena::pop_to

; 91   :     void Memory_Arena::pop_to(u64 position){

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 92   : 
; 93   :         if(position < this->position){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR position$[rsp], rax
	jae	$LN2@pop_to

; 94   : 
; 95   :             this->position = position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR position$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 96   : 
; 97   :             u64 aligned_position = AlignPow2Up(this->position, DEFAULT_ARENA_COMMIT_SIZE);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 67108863				; 03ffffffH
	and	rax, -67108864				; fffffffffc000000H
	mov	QWORD PTR aligned_position$2[rsp], rax

; 98   :             u64 next_commit_position = d_min(aligned_position, this->capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR aligned_position$2[rsp], rax
	jae	SHORT $LN5@pop_to
	mov	rax, QWORD PTR aligned_position$2[rsp]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN6@pop_to
$LN5@pop_to:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv74[rsp], rax
$LN6@pop_to:
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR next_commit_position$1[rsp], rax

; 99   : 
; 100  :             if(next_commit_position < this->commit_position){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR next_commit_position$1[rsp], rax
	jae	SHORT $LN3@pop_to

; 101  : 
; 102  :                 u64 decommission_size = this->commit_position - next_commit_position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR next_commit_position$1[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	mov	QWORD PTR decommission_size$3[rsp], rax

; 103  :                 d_decommit((u_ptr)(this + next_commit_position), decommission_size);

	imul	rax, QWORD PTR next_commit_position$1[rsp], 32 ; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR decommission_size$3[rsp]
	mov	rcx, rax
	call	?os_decommit_memory@d_std@@YAX_K0@Z	; d_std::os_decommit_memory

; 104  :                 this->commit_position = next_commit_position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR next_commit_position$1[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN3@pop_to:
$LN2@pop_to:

; 105  : 
; 106  :             }
; 107  : 
; 108  :         }
; 109  : 
; 110  :     }

	add	rsp, 72					; 00000048H
	ret	0
?pop_to@Memory_Arena@d_std@@QEAAX_K@Z ENDP		; d_std::Memory_Arena::pop_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
memory$ = 32
aligned_position$1 = 40
tv89 = 48
commit_size$2 = 56
next_commit_position$3 = 64
this$ = 96
size$ = 104
?push@Memory_Arena@d_std@@QEAA_K_K@Z PROC		; d_std::Memory_Arena::push

; 66   :     u_ptr Memory_Arena::push(u64 size) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 67   : 
; 68   :         u_ptr memory = 0;

	mov	QWORD PTR memory$[rsp], 0

; 69   :         if(size + this->position < capacity){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, QWORD PTR [rcx]
	jae	$LN2@push

; 70   :             if(size + this->position <= commit_position){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, QWORD PTR [rcx+16]
	ja	SHORT $LN3@push

; 71   :                 memory = (u_ptr)this + this->position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR memory$[rsp], rax

; 72   :                 this->position += size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 73   :             } else {

	jmp	$LN4@push
$LN3@push:

; 74   : 
; 75   :                 memory = (u_ptr)this + this->position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR memory$[rsp], rax

; 76   :                 this->position += size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 77   : 
; 78   :                 u64 aligned_position = AlignPow2Up(this->position, DEFAULT_ARENA_COMMIT_SIZE);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 67108863				; 03ffffffH
	and	rax, -67108864				; fffffffffc000000H
	mov	QWORD PTR aligned_position$1[rsp], rax

; 79   :                 u64 next_commit_position = d_min(aligned_position, this->capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR aligned_position$1[rsp], rax
	jae	SHORT $LN6@push
	mov	rax, QWORD PTR aligned_position$1[rsp]
	mov	QWORD PTR tv89[rsp], rax
	jmp	SHORT $LN7@push
$LN6@push:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv89[rsp], rax
$LN7@push:
	mov	rax, QWORD PTR tv89[rsp]
	mov	QWORD PTR next_commit_position$3[rsp], rax

; 80   :                 u64 commit_size = next_commit_position - this->commit_position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR next_commit_position$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR commit_size$2[rsp], rax

; 81   : 
; 82   :                 d_commit((u_ptr)this + this->commit_position, commit_size);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR commit_size$2[rsp]
	mov	rcx, rax
	call	?os_commit_memory@d_std@@YAX_K0@Z	; d_std::os_commit_memory

; 83   :                 this->commit_position += commit_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, QWORD PTR commit_size$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax
$LN4@push:
$LN2@push:

; 84   : 
; 85   :             }
; 86   :         }
; 87   : 
; 88   :         return memory;

	mov	rax, QWORD PTR memory$[rsp]

; 89   :     }

	add	rsp, 88					; 00000058H
	ret	0
?push@Memory_Arena@d_std@@QEAA_K_K@Z ENDP		; d_std::Memory_Arena::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
tv65 = 32
this$ = 64
address$ = 72
?deallocate@Memory_Arena@d_std@@QEAAX_K@Z PROC		; d_std::Memory_Arena::deallocate

; 55   :     void Memory_Arena::deallocate(u_ptr address) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 56   : 
; 57   :         switch(this->type){

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@deallocate
	jmp	SHORT $LN2@deallocate
$LN4@deallocate:

; 58   :             case(Memory_Arena_Type_Linear):
; 59   :                 this->pop_to(address - (u_ptr)this);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR address$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?pop_to@Memory_Arena@d_std@@QEAAX_K@Z	; d_std::Memory_Arena::pop_to
	npad	1
$LN2@deallocate:

; 60   :                 break;
; 61   :         }
; 62   : 
; 63   :         return;
; 64   :     }

	add	rsp, 56					; 00000038H
	ret	0
?deallocate@Memory_Arena@d_std@@QEAAX_K@Z ENDP		; d_std::Memory_Arena::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
tv65 = 32
result$ = 40
this$ = 64
size$ = 72
?allocate@Memory_Arena@d_std@@QEAA_K_K@Z PROC		; d_std::Memory_Arena::allocate

; 43   :     u_ptr Memory_Arena::allocate(u64 size) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 44   : 
; 45   :         u_ptr result = 0;

	mov	QWORD PTR result$[rsp], 0

; 46   :         switch(this->type){

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@allocate
	jmp	SHORT $LN2@allocate
$LN4@allocate:

; 47   :             case(Memory_Arena_Type_Linear):
; 48   :                 result = this->push(size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?push@Memory_Arena@d_std@@QEAA_K_K@Z	; d_std::Memory_Arena::push
	mov	QWORD PTR result$[rsp], rax
$LN2@allocate:

; 49   :                 break;
; 50   :         }
; 51   : 
; 52   :         return result;

	mov	rax, QWORD PTR result$[rsp]

; 53   :     }

	add	rsp, 56					; 00000038H
	ret	0
?allocate@Memory_Arena@d_std@@QEAA_K_K@Z ENDP		; d_std::Memory_Arena::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?reset@Memory_Arena@d_std@@QEAAXXZ PROC			; d_std::Memory_Arena::reset

; 32   :     void Memory_Arena::reset() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 33   : 
; 34   :         switch(this->type){

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@reset
	jmp	SHORT $LN2@reset
$LN4@reset:

; 35   :             case(Memory_Arena_Type_Linear):
; 36   :                 this->pop_all();

	mov	rcx, QWORD PTR this$[rsp]
	call	?pop_all@Memory_Arena@d_std@@QEAAXXZ	; d_std::Memory_Arena::pop_all
	npad	1
$LN2@reset:

; 37   :                 break;
; 38   :         }
; 39   : 
; 40   :         return;
; 41   :     }

	add	rsp, 56					; 00000038H
	ret	0
?reset@Memory_Arena@d_std@@QEAAXXZ ENDP			; d_std::Memory_Arena::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
this$ = 48
?release@Memory_Arena@d_std@@QEAAXXZ PROC		; d_std::Memory_Arena::release

; 27   :     void Memory_Arena::release() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 28   :         d_release((u_ptr)this);

	mov	rcx, QWORD PTR this$[rsp]
	call	?os_release_memory@d_std@@YAX_K@Z	; d_std::os_release_memory
	npad	1

; 29   :         return;
; 30   :     }

	add	rsp, 40					; 00000028H
	ret	0
?release@Memory_Arena@d_std@@QEAAXXZ ENDP		; d_std::Memory_Arena::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
file$ = 48
?close_file@d_std@@YA_NUFile@1@@Z PROC			; d_std::close_file

; 227  :     bool close_file(File file){

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 228  :         if(CloseHandle(file.handle) == 0){

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp_CloseHandle
	test	eax, eax
	jne	SHORT $LN2@close_file

; 229  :             os_debug_printf("close_file failed!", GetLastError());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG70174
	call	?os_debug_printf@d_std@@YAXPEBDZZ	; d_std::os_debug_printf

; 230  :             return false;

	xor	al, al
	jmp	SHORT $LN1@close_file
$LN2@close_file:

; 231  :         }
; 232  :         return true;

	mov	al, 1
$LN1@close_file:

; 233  :     }

	add	rsp, 40					; 00000028H
	ret	0
?close_file@d_std@@YA_NUFile@1@@Z ENDP			; d_std::close_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
num_bytes_read$ = 48
result$ = 52
__$ReturnAddress$ = 80
arena$ = 88
file$ = 96
bytes_to_read$ = 104
?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z PROC ; d_std::read_file

; 199  :     d_string read_file(Memory_Arena* arena, File file, u32 bytes_to_read){

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 200  :         d_string return_string;
; 201  :         return_string.string = arena->allocate_array<char>(bytes_to_read);

	mov	eax, DWORD PTR bytes_to_read$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 202  : 
; 203  :         DWORD num_bytes_read = 0;

	mov	DWORD PTR num_bytes_read$[rsp], 0

; 204  : 
; 205  :         BOOL result = ReadFile(

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR num_bytes_read$[rsp]
	mov	r8d, DWORD PTR bytes_to_read$[rsp]
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp_ReadFile
	mov	DWORD PTR result$[rsp], eax

; 206  :             file.handle,
; 207  :             return_string.string,
; 208  :             bytes_to_read,
; 209  :             &num_bytes_read,
; 210  :             NULL
; 211  :         );
; 212  : 
; 213  :         if(result == 0){

	cmp	DWORD PTR result$[rsp], 0
	jne	SHORT $LN2@read_file

; 214  :             arena->deallocate_array(return_string.string);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ; d_std::Memory_Arena::deallocate_array<char>

; 215  :             return_string.string = NULL;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rax], 0

; 216  :             return_string.size   = 0;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], 0

; 217  :             return return_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@read_file
$LN2@read_file:

; 218  :         }
; 219  : 
; 220  :         return_string.size = num_bytes_read;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR num_bytes_read$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 221  : 
; 222  :         arena->deallocate((u_ptr)return_string.string + num_bytes_read);

	mov	eax, DWORD PTR num_bytes_read$[rsp]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rdx, rax
	mov	rcx, QWORD PTR arena$[rsp]
	call	?deallocate@Memory_Arena@d_std@@QEAAX_K@Z ; d_std::Memory_Arena::deallocate

; 223  : 
; 224  :         return return_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@read_file:

; 225  :     }

	add	rsp, 72					; 00000048H
	ret	0
?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z ENDP ; d_std::read_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
dwDesiredAccess$ = 64
file_size$ = 68
os_file_handle$ = 72
__$ReturnAddress$ = 96
file_name$ = 104
permissions$ = 112
?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z PROC		; d_std::open_file

; 144  :     File open_file(const char* file_name, const char* permissions){

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 145  : 
; 146  :         DWORD dwDesiredAccess = 0;

	mov	DWORD PTR dwDesiredAccess$[rsp], 0

; 147  : 
; 148  :         if(permissions != NULL){

	cmp	QWORD PTR permissions$[rsp], 0
	je	SHORT $LN2@open_file

; 149  :             // First Char
; 150  :             if(*permissions == 'r'){

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 114				; 00000072H
	jne	SHORT $LN3@open_file

; 151  :                 dwDesiredAccess |= GENERIC_READ;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 31
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
	jmp	SHORT $LN4@open_file
$LN3@open_file:

; 152  :             } else if (*permissions == 'w') {

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 119				; 00000077H
	jne	SHORT $LN5@open_file

; 153  :                 dwDesiredAccess |= GENERIC_WRITE;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 30
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
$LN5@open_file:
$LN4@open_file:

; 154  :             }
; 155  :             permissions++;

	mov	rax, QWORD PTR permissions$[rsp]
	inc	rax
	mov	QWORD PTR permissions$[rsp], rax

; 156  :             // Second Char
; 157  :             if(*permissions == 'r'){

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 114				; 00000072H
	jne	SHORT $LN6@open_file

; 158  :                 dwDesiredAccess |= GENERIC_READ;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 31
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
	jmp	SHORT $LN7@open_file
$LN6@open_file:

; 159  :             } else if (*permissions == 'w') {

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 119				; 00000077H
	jne	SHORT $LN8@open_file

; 160  :                 dwDesiredAccess |= GENERIC_WRITE;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 30
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
$LN8@open_file:
$LN7@open_file:
$LN2@open_file:

; 161  :             }
; 162  :         }
; 163  : 
; 164  : 
; 165  :         HANDLE os_file_handle = CreateFileA(

	mov	QWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, DWORD PTR dwDesiredAccess$[rsp]
	mov	rcx, QWORD PTR file_name$[rsp]
	call	QWORD PTR __imp_CreateFileA
	mov	QWORD PTR os_file_handle$[rsp], rax

; 166  :             file_name,
; 167  :             dwDesiredAccess,
; 168  :             0,
; 169  :             NULL,
; 170  :             OPEN_EXISTING,
; 171  :             FILE_ATTRIBUTE_NORMAL,
; 172  :             NULL
; 173  :         );
; 174  : 
; 175  :         if(os_file_handle == INVALID_HANDLE_VALUE){

	cmp	QWORD PTR os_file_handle$[rsp], -1
	jne	SHORT $LN9@open_file

; 176  :             os_debug_printf("open_file failed to create file handle! last error: %u", GetLastError());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG70157
	call	?os_debug_printf@d_std@@YAXPEBDZZ	; d_std::os_debug_printf

; 177  :             File error_file;
; 178  :             error_file.handle = INVALID_HANDLE_VALUE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rax], -1

; 179  :             error_file.size   = INVALID_FILE_SIZE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH

; 180  :             return error_file;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@open_file
$LN9@open_file:

; 181  :         }
; 182  : 
; 183  :         DWORD file_size = GetFileSize(os_file_handle, NULL);

	xor	edx, edx
	mov	rcx, QWORD PTR os_file_handle$[rsp]
	call	QWORD PTR __imp_GetFileSize
	mov	DWORD PTR file_size$[rsp], eax

; 184  :         if(file_size == INVALID_FILE_SIZE){

	cmp	DWORD PTR file_size$[rsp], -1		; ffffffffH
	jne	SHORT $LN10@open_file

; 185  :             os_debug_printf("open_file failed to get file size! last error: %u", GetLastError());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG70159
	call	?os_debug_printf@d_std@@YAXPEBDZZ	; d_std::os_debug_printf

; 186  :             File error_file;
; 187  :             error_file.handle = INVALID_HANDLE_VALUE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rax], -1

; 188  :             error_file.size   = INVALID_FILE_SIZE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH

; 189  :             return error_file;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@open_file
$LN10@open_file:

; 190  :         }
; 191  : 
; 192  :         File return_file;
; 193  :         return_file.handle = os_file_handle;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR os_file_handle$[rsp]
	mov	QWORD PTR [rax], rcx

; 194  :         return_file.size   = file_size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR file_size$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 195  : 
; 196  :         return return_file;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@open_file:

; 197  :     }

	add	rsp, 88					; 00000058H
	ret	0
?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z ENDP		; d_std::open_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
tv66 = 32
?is_debugger_present@d_std@@YA_NXZ PROC			; d_std::is_debugger_present

; 131  :     bool is_debugger_present(){

$LN5:
	sub	rsp, 56					; 00000038H

; 132  :         return  (bool) IsDebuggerPresent();

	call	QWORD PTR __imp_IsDebuggerPresent
	test	eax, eax
	je	SHORT $LN3@is_debugge
	mov	BYTE PTR tv66[rsp], 1
	jmp	SHORT $LN4@is_debugge
$LN3@is_debugge:
	mov	BYTE PTR tv66[rsp], 0
$LN4@is_debugge:
	movzx	eax, BYTE PTR tv66[rsp]

; 133  :     }

	add	rsp, 56					; 00000038H
	ret	0
?is_debugger_present@d_std@@YA_NXZ ENDP			; d_std::is_debugger_present
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
$T3 = 40
$T4 = 48
c_str$ = 64
__$ArrayPad$ = 576
string$ = 608
?os_debug_print@d_std@@YAXUd_string@1@@Z PROC		; d_std::os_debug_print

; 51   :     {

$LN15:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 600				; 00000258H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 52   : 
; 53   :         char c_str[501]; 
; 54   : 
; 55   :         if(string.size > 500){

	mov	rax, QWORD PTR string$[rsp]
	cmp	DWORD PTR [rax+8], 500			; 000001f4H
	jbe	$LN8@os_debug_p

; 56   : 
; 57   :             OutputDebugStringA("(os_debug_print) Error: string size is more than 500 characters. Printing first 500.\n");

	lea	rcx, OFFSET FLAT:$SG70095
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1

; 58   : 
; 59   :             for(int i = 0; i < 500; i++){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@os_debug_p
$LN2@os_debug_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@os_debug_p:
	cmp	DWORD PTR i$1[rsp], 500			; 000001f4H
	jge	SHORT $LN3@os_debug_p

; 60   :                 c_str[i] = string.string[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR i$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR c_str$[rsp+rdx], al

; 61   :             }

	jmp	SHORT $LN2@os_debug_p
$LN3@os_debug_p:

; 62   : 
; 63   :             c_str[500] = '\0';

	mov	eax, 1
	imul	rax, rax, 500				; 000001f4H
	mov	QWORD PTR $T3[rsp], rax
	cmp	QWORD PTR $T3[rsp], 501			; 000001f5H
	jae	SHORT $LN11@os_debug_p
	jmp	SHORT $LN12@os_debug_p
$LN11@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN12@os_debug_p:
	mov	rax, QWORD PTR $T3[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 64   : 
; 65   :             OutputDebugStringA(c_str);

	lea	rcx, QWORD PTR c_str$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1

; 66   :             
; 67   : 
; 68   :         } else {

	jmp	SHORT $LN9@os_debug_p
$LN8@os_debug_p:

; 69   : 
; 70   :             for(int i = 0; i < string.size; i++){

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@os_debug_p
$LN5@os_debug_p:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@os_debug_p:
	mov	rax, QWORD PTR string$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN6@os_debug_p

; 71   :                 c_str[i] = string.string[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR i$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR c_str$[rsp+rdx], al

; 72   :             }

	jmp	SHORT $LN5@os_debug_p
$LN6@os_debug_p:

; 73   : 
; 74   :             c_str[string.size] = '\0';

	mov	rax, QWORD PTR string$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	QWORD PTR $T4[rsp], rax
	cmp	QWORD PTR $T4[rsp], 501			; 000001f5H
	jae	SHORT $LN13@os_debug_p
	jmp	SHORT $LN14@os_debug_p
$LN13@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN14@os_debug_p:
	mov	rax, QWORD PTR $T4[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 75   : 
; 76   :             OutputDebugStringA(c_str);

	lea	rcx, QWORD PTR c_str$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1
$LN9@os_debug_p:
$LN10@os_debug_p:

; 77   : 
; 78   :         }
; 79   : 
; 80   :         return;
; 81   : 
; 82   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 600				; 00000258H
	ret	0
?os_debug_print@d_std@@YAXUd_string@1@@Z ENDP		; d_std::os_debug_print
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
$T1 = 32
va_args$ = 40
return_string$ = 48
$T2 = 64
$T3 = 80
c_str$ = 96
__$ArrayPad$ = 608
arena$ = 656
lit_string$ = 664
?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ PROC ; d_std::os_debug_printf

; 88   :     void __cdecl os_debug_printf(Memory_Arena *arena, char* lit_string, ...){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rsi
	push	rdi
	sub	rsp, 632				; 00000278H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 
; 90   :         // va_list
; 91   :         u_ptr va_args;
; 92   : 
; 93   :         // va_start
; 94   :         va_args = (u_ptr)(&lit_string + 1);

	lea	rax, QWORD PTR lit_string$[rsp+8]
	mov	QWORD PTR va_args$[rsp], rax

; 95   : 
; 96   :         char c_str[501]; 
; 97   :         c_str[500] = '\0';

	mov	eax, 1
	imul	rax, rax, 500				; 000001f4H
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 501			; 000001f5H
	jae	SHORT $LN3@os_debug_p
	jmp	SHORT $LN4@os_debug_p
$LN3@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN4@os_debug_p:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 98   : 
; 99   :         d_string return_string = _format_lit_string(arena, lit_string, va_args);

	mov	r9, QWORD PTR va_args$[rsp]
	mov	r8, QWORD PTR lit_string$[rsp]
	mov	rdx, QWORD PTR arena$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ; d_std::_format_lit_string
	lea	rcx, QWORD PTR return_string$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 100  : 
; 101  :         os_debug_print(return_string);

	lea	rax, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR return_string$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rcx, QWORD PTR $T2[rsp]
	call	?os_debug_print@d_std@@YAXUd_string@1@@Z ; d_std::os_debug_print
	npad	1
$LN2@os_debug_p:

; 102  : 
; 103  :         return;
; 104  : 
; 105  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 632				; 00000278H
	pop	rdi
	pop	rsi
	ret	0
?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ ENDP ; d_std::os_debug_printf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
string$ = 48
?os_debug_print@d_std@@YAXPEBD@Z PROC			; d_std::os_debug_print

; 46   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 47   :         OutputDebugStringA(string);

	mov	rcx, QWORD PTR string$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1

; 48   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_debug_print@d_std@@YAXPEBD@Z ENDP			; d_std::os_debug_print
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 48
?os_release_memory@d_std@@YAX_K@Z PROC			; d_std::os_release_memory

; 39   :     void os_release_memory (u_ptr memory){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 40   : 
; 41   :         VirtualFree((LPVOID)memory, 0, MEM_RELEASE);

	mov	r8d, 32768				; 00008000H
	xor	edx, edx
	mov	rcx, QWORD PTR memory$[rsp]
	call	QWORD PTR __imp_VirtualFree
	npad	1

; 42   : 
; 43   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_release_memory@d_std@@YAX_K@Z ENDP			; d_std::os_release_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 48
size$ = 56
?os_decommit_memory@d_std@@YAX_K0@Z PROC		; d_std::os_decommit_memory

; 33   :     void os_decommit_memory(u_ptr memory, u64 size){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 34   : 
; 35   :         VirtualFree((LPVOID)memory, size, MEM_DECOMMIT);

	mov	r8d, 16384				; 00004000H
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR memory$[rsp]
	call	QWORD PTR __imp_VirtualFree
	npad	1

; 36   : 
; 37   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_decommit_memory@d_std@@YAX_K0@Z ENDP		; d_std::os_decommit_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 48
size$ = 56
?os_commit_memory@d_std@@YAX_K0@Z PROC			; d_std::os_commit_memory

; 26   :     void os_commit_memory (u_ptr memory, u64 size){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 27   : 
; 28   :         VirtualAlloc((LPVOID)memory, size, MEM_COMMIT, PAGE_READWRITE);

	mov	r9d, 4
	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR memory$[rsp]
	call	QWORD PTR __imp_VirtualAlloc
	npad	1

; 29   :         return;
; 30   : 
; 31   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_commit_memory@d_std@@YAX_K0@Z ENDP			; d_std::os_commit_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 32
size$ = 64
?os_reserve_memory@d_std@@YA_K_K@Z PROC			; d_std::os_reserve_memory

; 19   :     u_ptr os_reserve_memory (u64 size){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 20   : 
; 21   :         u_ptr  memory = (u_ptr)VirtualAlloc(nullptr, size, MEM_RESERVE, PAGE_READWRITE);

	mov	r9d, 4
	mov	r8d, 8192				; 00002000H
	mov	rdx, QWORD PTR size$[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_VirtualAlloc
	mov	QWORD PTR memory$[rsp], rax

; 22   :         return memory;

	mov	rax, QWORD PTR memory$[rsp]

; 23   : 
; 24   :     }

	add	rsp, 56					; 00000038H
	ret	0
?os_reserve_memory@d_std@@YA_K_K@Z ENDP			; d_std::os_reserve_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
capacity$ = 32
temp$1 = 40
placement_ptr$2 = 48
it$ = 56
temp$3 = 64
placement_ptr$4 = 72
tv91 = 80
i$5 = 84
double_input$6 = 88
input_string_iterator$7 = 96
placement_ptr$8 = 104
placement_ptr$9 = 112
integer_part$10 = 120
number$11 = 128
decimal_part$12 = 136
c_str$13 = 144
d_str$14 = 152
__$ReturnAddress$ = 208
arena$ = 216
lit_string$ = 224
va_args$ = 232
?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z PROC ; d_std::_format_lit_string

; 308  :     d_string __cdecl _format_lit_string(Memory_Arena *arena, char* lit_string, u_ptr va_args){

$LN56:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H

; 309  : 
; 310  :         // it iterates through the original string
; 311  :         char* it = lit_string;

	mov	rax, QWORD PTR lit_string$[rsp]
	mov	QWORD PTR it$[rsp], rax

; 312  : 
; 313  :         u32 capacity = 50;

	mov	DWORD PTR capacity$[rsp], 50		; 00000032H

; 314  :         d_string return_string;
; 315  : 
; 316  :         // Current place in new string is kept track of with size
; 317  :         return_string.string = arena->allocate_array<char>(capacity);

	mov	eax, DWORD PTR capacity$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 318  :         return_string.size = 0;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], 0
$LN2@format_lit:

; 319  : 
; 320  : 
; 321  :         while( *it != '\0'){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@format_lit
$LN4@format_lit:

; 322  : 
; 323  :             while( *it != '%' && *it != '\0'){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	$LN5@format_lit
	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN5@format_lit

; 324  :                 return_string.string[return_string.size] = *it;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR it$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl

; 325  :                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 326  :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 327  :                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN31@format_lit

; 328  :                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 329  :                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN31@format_lit:

; 330  :                 }
; 331  :             }

	jmp	$LN4@format_lit
$LN5@format_lit:

; 332  : 
; 333  :             if ( *it == '%' ) {

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN32@format_lit

; 334  :                 if ( *(it+1) != '\0' ){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	$LN33@format_lit

; 335  :                     
; 336  :                     // Switch based on argument type
; 337  :                     switch(*(it+1)){

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR tv91[rsp], al
	cmp	BYTE PTR tv91[rsp], 36			; 00000024H
	je	$LN39@format_lit
	cmp	BYTE PTR tv91[rsp], 102			; 00000066H
	je	$LN41@format_lit
	cmp	BYTE PTR tv91[rsp], 115			; 00000073H
	je	$LN37@format_lit
	cmp	BYTE PTR tv91[rsp], 117			; 00000075H
	je	SHORT $LN34@format_lit
	jmp	$LN6@format_lit
$LN34@format_lit:

; 338  : 
; 339  :                         // Unsigned int
; 340  :                         case('u'):
; 341  :                         {
; 342  :                             u64 number = *(u64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR number$11[rsp], rax

; 343  :                             va_args += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 344  : 
; 345  :                             char* placement_ptr = return_string.string + return_string.size - 1;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rcx+rax-1]
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 346  : 
; 347  :                             // Guarantee one spot. What if "number" is 0?
; 348  :                             u64 temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 349  :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 350  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 351  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN35@format_lit

; 352  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 353  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN35@format_lit:

; 354  :                             }
; 355  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 356  : 
; 357  :                             // Find the reset of the space this number will take up in the string
; 358  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN10@format_lit
$LN8@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
$LN10@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN9@format_lit

; 359  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 360  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 361  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN36@format_lit

; 362  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 363  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN36@format_lit:

; 364  :                                 }
; 365  :                             }

	jmp	$LN8@format_lit
$LN9@format_lit:

; 366  : 
; 367  :                             // Insert the numbers from smallest (right) to largest (left)
; 368  :                             temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 369  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 370  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 371  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 372  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN13@format_lit
$LN11@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax
$LN13@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN12@format_lit

; 373  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 374  :                             }

	jmp	SHORT $LN11@format_lit
$LN12@format_lit:

; 375  : 
; 376  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 377  :                         }
; 378  :                         break;

	jmp	$LN6@format_lit
$LN37@format_lit:

; 379  : 
; 380  :                         // C string
; 381  :                         case('s'):
; 382  :                         {
; 383  :                             char* c_str = *(char**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR c_str$13[rsp], rax

; 384  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 385  : 
; 386  :                             char* placement_ptr = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 387  : 
; 388  :                             char* input_string_iterator = (char*)c_str;

	mov	rax, QWORD PTR c_str$13[rsp]
	mov	QWORD PTR input_string_iterator$7[rsp], rax
$LN14@format_lit:

; 389  : 
; 390  :                             while(*input_string_iterator != '\0'){

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN15@format_lit

; 391  : 
; 392  :                                 // Set char in output string 
; 393  :                                 *placement_ptr = *input_string_iterator;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	mov	rcx, QWORD PTR input_string_iterator$7[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 394  : 
; 395  :                                 // Advance Iterators
; 396  :                                 input_string_iterator++;

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	inc	rax
	mov	QWORD PTR input_string_iterator$7[rsp], rax

; 397  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 398  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 399  : 
; 400  :                                 // Possibly allocate more memory
; 401  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN38@format_lit

; 402  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 403  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN38@format_lit:

; 404  :                                 }
; 405  :                             }

	jmp	$LN14@format_lit
$LN15@format_lit:

; 406  : 
; 407  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 408  :                         }
; 409  :                         break;

	jmp	$LN6@format_lit
$LN39@format_lit:

; 410  : 
; 411  :                         // d_std::d_string
; 412  :                         case('$'):
; 413  :                         {
; 414  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 415  :                             d_string d_str = **(d_string**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	lea	rcx, QWORD PTR d_str$14[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 416  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 417  : 
; 418  :                             char* placement_ptr = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 419  : 
; 420  :                             //char* input_string_iterator = (char*)d_str.string;
; 421  : 
; 422  :                             for(int i = 0; i < d_str.size; i++){

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN18@format_lit
$LN16@format_lit:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN18@format_lit:
	mov	eax, DWORD PTR d_str$14[rsp+8]
	cmp	DWORD PTR i$5[rsp], eax
	jae	$LN17@format_lit

; 423  : 
; 424  :                                 // Set char in output string 
; 425  :                                 *placement_ptr = d_str.string[i];

	movsxd	rax, DWORD PTR i$5[rsp]
	mov	rcx, QWORD PTR placement_ptr$9[rsp]
	mov	rdx, QWORD PTR d_str$14[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al

; 426  : 
; 427  :                                 // Advance Iterators
; 428  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$9[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 429  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 430  : 
; 431  :                                 // Possibly allocate more memory
; 432  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN40@format_lit

; 433  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 434  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN40@format_lit:

; 435  :                                 }
; 436  :                             }

	jmp	$LN16@format_lit
$LN17@format_lit:

; 437  : 
; 438  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 439  :                         }
; 440  :                         break;

	jmp	$LN6@format_lit
$LN41@format_lit:

; 441  : 
; 442  :                         // d_std::d_string
; 443  :                         case('f'):
; 444  :                         {
; 445  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 446  :                             double double_input = *(f64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR double_input$6[rsp], xmm0

; 447  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 448  : 
; 449  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN42@format_lit

; 450  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 451  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN42@format_lit:

; 452  :                             }
; 453  : 
; 454  :                             char* placement_ptr     = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 455  : 
; 456  :                             // Check and possibly add sign bit
; 457  :                             if(double_input < 0){

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR double_input$6[rsp]
	jbe	$LN43@format_lit

; 458  : 
; 459  :                                 // Add negative char in output string
; 460  :                                 *placement_ptr = '-';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 461  : 
; 462  :                                 // Advance Iterators
; 463  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 464  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 465  : 
; 466  :                                 // Possibly allocate more memory
; 467  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN44@format_lit

; 468  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 469  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN44@format_lit:

; 470  :                                 }
; 471  : 
; 472  :                                 double_input *= -1;

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	mulsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR double_input$6[rsp], xmm0
$LN43@format_lit:

; 473  : 
; 474  :                             }
; 475  : 
; 476  :                             u64 integer_part = (u64)double_input;

	xor	eax, eax
	movsd	xmm0, QWORD PTR double_input$6[rsp]
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN55@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN55@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN55@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR integer_part$10[rsp], rax

; 477  : 
; 478  :                             // Guarantee one spot. What if "number" is 0?
; 479  :                             u64 temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 480  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 481  :                             // Possibly allocate more memory
; 482  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN45@format_lit

; 483  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 484  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN45@format_lit:

; 485  :                             }
; 486  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 487  : 
; 488  :                             // Find the reset of the space this number will take up in the string
; 489  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN21@format_lit
$LN19@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN21@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN20@format_lit

; 490  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 491  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 492  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN46@format_lit

; 493  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 494  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN46@format_lit:

; 495  :                                 }
; 496  :                             }

	jmp	$LN19@format_lit
$LN20@format_lit:

; 497  : 
; 498  :                             // Insert the numbers from smallest (right) to largest (left)
; 499  :                             temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 500  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 501  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 502  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 503  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN24@format_lit
$LN22@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN24@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN23@format_lit

; 504  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 505  :                             }

	jmp	SHORT $LN22@format_lit
$LN23@format_lit:

; 506  : 
; 507  :                             placement_ptr     = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 508  : 
; 509  :                             // Insert decimal place
; 510  :                             *placement_ptr = '.';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 511  : 
; 512  :                             // Advance Iterators
; 513  :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 514  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 515  : 
; 516  :                             // Possibly allocate more memory
; 517  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN47@format_lit

; 518  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 519  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN47@format_lit:

; 520  :                             }
; 521  : 
; 522  :                             u64 decimal_part = (((double_input + 0.00001 )- (float)integer_part) * 1000.);

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	addsd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	mov	rax, QWORD PTR integer_part$10[rsp]
	test	rax, rax
	jl	SHORT $LN53@format_lit
	cvtsi2ss xmm1, rax
	jmp	SHORT $LN54@format_lit
$LN53@format_lit:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
$LN54@format_lit:
	cvtss2sd xmm1, xmm1
	subsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN52@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN52@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN52@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR decimal_part$12[rsp], rax

; 523  : 
; 524  :                             // Guarantee one spot. What if "number" is 0?
; 525  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 526  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 527  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 528  : 
; 529  :                             // Find the reset of the space this number will take up in the string
; 530  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN27@format_lit
$LN25@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN27@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN26@format_lit

; 531  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 532  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 533  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN48@format_lit

; 534  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 535  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN48@format_lit:

; 536  :                                 }
; 537  :                             }

	jmp	$LN25@format_lit
$LN26@format_lit:

; 538  : 
; 539  :                             // Insert the numbers from smallest (right) to largest (left)
; 540  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 541  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 542  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 543  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 544  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN30@format_lit
$LN28@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN30@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN29@format_lit

; 545  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 546  :                             }

	jmp	SHORT $LN28@format_lit
$LN29@format_lit:

; 547  : 
; 548  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
$LN6@format_lit:
$LN33@format_lit:

; 549  :                         }
; 550  :                         break;
; 551  :                     }
; 552  :                 }
; 553  :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 554  :                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN49@format_lit

; 555  :                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 556  :                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN49@format_lit:
$LN32@format_lit:

; 557  :                 }
; 558  :             }
; 559  : 
; 560  :         }

	jmp	$LN2@format_lit
$LN3@format_lit:

; 561  : 
; 562  :         // Release memory from 
; 563  :         if(return_string.size < capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jae	SHORT $LN50@format_lit

; 564  :             arena->deallocate_array(return_string.string + return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rdx, rax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ; d_std::Memory_Arena::deallocate_array<char>
	npad	1
$LN50@format_lit:

; 565  :         }
; 566  : 
; 567  :         return return_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 568  : 
; 569  :     }

	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ENDP ; d_std::_format_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
va_args$ = 32
$T1 = 40
__$ReturnAddress$ = 96
arena$ = 104
lit_string$ = 112
?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ PROC ; d_std::format_lit_string

; 39   :     d_string __cdecl format_lit_string(Memory_Arena *arena, char* lit_string, ...){

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 40   : 
; 41   :         // va_list
; 42   :         u_ptr va_args;
; 43   : 
; 44   :         // va_start
; 45   :         va_args = (u_ptr)(&lit_string + 1);

	lea	rax, QWORD PTR lit_string$[rsp+8]
	mov	QWORD PTR va_args$[rsp], rax

; 46   : 
; 47   :         return _format_lit_string(arena, lit_string, va_args);

	mov	r9, QWORD PTR va_args$[rsp]
	mov	r8, QWORD PTR lit_string$[rsp]
	mov	rdx, QWORD PTR arena$[rsp]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	call	?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ; d_std::_format_lit_string
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 48   : 
; 49   :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ ENDP ; d_std::format_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
i$1 = 32
size$ = 36
p$ = 40
__$ReturnAddress$ = 64
arena$ = 72
lit_string$ = 80
?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z PROC ; d_std::string_from_lit_string

; 19   :     d_string string_from_lit_string(Memory_Arena *arena, char* lit_string){

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 20   : 
; 21   :         d_string string;
; 22   :         u32 size = 0;

	mov	DWORD PTR size$[rsp], 0

; 23   :         char* p = const_cast<char*>(lit_string);

	mov	rax, QWORD PTR lit_string$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@string_fro:

; 24   :         while (*p != '\0'){

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@string_fro

; 25   :             size++;

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax

; 26   :             p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 27   :         }

	jmp	SHORT $LN2@string_fro
$LN3@string_fro:

; 28   :         string.size = size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 29   :         string.string = arena->allocate_array<char>(string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 30   : 
; 31   :         for(int i = 0; i < string.size; i++){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@string_fro
$LN4@string_fro:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@string_fro:
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN5@string_fro

; 32   :             string.string[i] = lit_string[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR lit_string$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 33   :         }

	jmp	SHORT $LN4@string_fro
$LN5@string_fro:

; 34   :         string.string[string.size] = '\0';

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rcx+rax], 0

; 35   : 
; 36   :         return string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 37   :     }

	add	rsp, 56					; 00000038H
	ret	0
?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z ENDP ; d_std::string_from_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
i$1 = 32
c_str$ = 40
this$ = 64
arena$ = 72
?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z PROC ; d_std::d_string::c_str

; 8    :     const char* d_string::c_str(Memory_Arena *arena){

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 9    :         char* c_str = arena->allocate_array<char>(size + 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	eax, eax
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	QWORD PTR c_str$[rsp], rax

; 10   : 
; 11   :         for(int i = 0; i < size; i++){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@c_str
$LN2@c_str:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@c_str:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN3@c_str

; 12   :             c_str[i] = string[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR i$1[rsp]
	mov	r8, QWORD PTR c_str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 13   :         }

	jmp	SHORT $LN2@c_str
$LN3@c_str:

; 14   :         c_str[size] = '\0';

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR c_str$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 15   : 
; 16   :         return c_str;

	mov	rax, QWORD PTR c_str$[rsp]

; 17   :     }

	add	rsp, 56					; 00000038H
	ret	0
?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z ENDP ; d_std::d_string::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1506 :     constexpr const _Ty1& _Get_first() const noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1507 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1508 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1502 :     constexpr _Ty1& _Get_first() noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 1503 :         return *this;

	mov	rax, QWORD PTR this$[rsp]

; 1504 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3085 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3086 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3087 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT

; 3081 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3082 :         return _Mypair._Get_first();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3083 :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
_My_data$ = 40
_Al$2 = 48
this$ = 80
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3055 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3056 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 3057 :         _My_data._Orphan_all();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Orphan_all@_Container_base12@std@@QEAAXXZ ; std::_Container_base12::_Orphan_all
	npad	1

; 3058 :         if (_My_data._Large_mode_engaged()) {

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Tidy_deall

; 3059 :             _ASAN_STRING_REMOVE(*this);
; 3060 :             auto& _Al = _Getal();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	QWORD PTR _Al$2[rsp], rax

; 3061 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	r8, QWORD PTR [rax+32]
	mov	rax, QWORD PTR _My_data$[rsp]
	mov	rdx, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR _Al$2[rsp]
	call	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity

; 3062 :             _My_data._Bx._Switch_to_buf();

	mov	rax, QWORD PTR _My_data$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
	npad	1
$LN2@Tidy_deall:

; 3063 :         }
; 3064 : 
; 3065 :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 0

; 3066 :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+32], 15

; 3067 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3068 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3069 :     }

	add	rsp, 72					; 00000048H
	ret	0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_New_size$ = 72
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 3049 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 3050 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 3051 :         _Mypair._Myval2._Mysize = _New_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _New_size$[rsp]
	mov	QWORD PTR [rax+24], rcx

; 3052 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
	add	rax, QWORD PTR _New_size$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 3053 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
tv76 = 32
tv74 = 40
this$ = 64
_Requested$ = 72
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2965 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2966 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

	mov	rcx, QWORD PTR this$[rsp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	mov	QWORD PTR tv76[rsp], rax
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR tv74[rsp], rax
	mov	r8, QWORD PTR tv76[rsp]
	mov	rdx, QWORD PTR tv74[rsp]
	mov	rcx, QWORD PTR _Requested$[rsp]
	call	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth

; 2967 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z
_TEXT	SEGMENT
_Masked$ = 32
$T1 = 40
_Requested$ = 64
_Old$ = 72
_Max$ = 80
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2952 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

$LN6:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2953 :         const size_type _Masked = _Requested | _Alloc_mask;

	mov	rax, QWORD PTR _Requested$[rsp]
	or	rax, 15
	mov	QWORD PTR _Masked$[rsp], rax

; 2954 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	mov	rax, QWORD PTR _Max$[rsp]
	cmp	QWORD PTR _Masked$[rsp], rax
	jbe	SHORT $LN2@Calculate_

; 2955 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2956 :         }
; 2957 : 
; 2958 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Max$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	cmp	QWORD PTR _Old$[rsp], rax
	jbe	SHORT $LN3@Calculate_

; 2959 :             return _Max;

	mov	rax, QWORD PTR _Max$[rsp]
	jmp	SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2960 :         }
; 2961 : 
; 2962 :         return (_STD max)(_Masked, _Old + _Old / 2);

	xor	edx, edx
	mov	rax, QWORD PTR _Old$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, QWORD PTR _Old$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR $T1[rsp], rax
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Masked$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
$LN1@Calculate_:

; 2963 :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CA_K_K00@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
$T1 = 32
_Alloc_max$ = 40
_Storage_max$ = 48
$T2 = 56
$T3 = 64
this$ = 96
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 2360 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2361 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rcx, rax
	call	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
	mov	QWORD PTR _Alloc_max$[rsp], rax

; 2362 :         const size_type _Storage_max = // can always store small string

	mov	QWORD PTR $T1[rsp], 16
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR _Alloc_max$[rsp]
	call	??$max@_K@std@@YAAEB_KAEB_K0@Z		; std::max<unsigned __int64>
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Storage_max$[rsp], rax

; 2363 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2364 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

	mov	rax, QWORD PTR _Storage_max$[rsp]
	dec	rax
	mov	QWORD PTR $T2[rsp], rax
	call	??$_Max_limit@_J@std@@YA_JXZ		; std::_Max_limit<__int64>
	mov	QWORD PTR $T3[rsp], rax
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	??$min@_K@std@@YAAEB_KAEB_K0@Z		; std::min<unsigned __int64>
	mov	rax, QWORD PTR [rax]

; 2365 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2366 :         );
; 2367 :     }

	add	rsp, 88					; 00000058H
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 48
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2338 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2339 :         return _Mypair._Myval2._Myptr();

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2340 :     }

	add	rsp, 40					; 00000028H
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$S5$ = 32
_To_delete$ = 40
_Alproxy$ = 48
this$ = 80
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1369 :     _CONSTEXPR20 ~basic_string() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1370 :         _Tidy_deallocate();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1371 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1372 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $S5$[rsp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	lea	rax, QWORD PTR $S5$[rsp]
	mov	QWORD PTR _Alproxy$[rsp], rax

; 1373 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _To_delete$[rsp], rax

; 1374 :         _Mypair._Myval2._Myproxy = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 1375 :         _Delete_plain_internal(_Alproxy, _To_delete);

	mov	rdx, QWORD PTR _To_delete$[rsp]
	mov	rcx, QWORD PTR _Alproxy$[rsp]
	call	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAEAV?$allocator@U_Container_proxy@std@@@0@QEAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
	npad	1

; 1376 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1377 :     }

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
	npad	1
	add	rsp, 72					; 00000048H
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 33
_My_data$ = 40
this$ = 64
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT

; 836  :     _CONSTEXPR20 void _Construct_empty() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 837  :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR _My_data$[rsp], rax

; 838  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
	mov	rdx, rax
	lea	rcx, QWORD PTR $T2[rsp]
	call	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
	mov	rdx, rax
	mov	rcx, QWORD PTR _My_data$[rsp]
	call	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QEAAX$$QEAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
	npad	1

; 839  : 
; 840  :         // initialize basic_string data members
; 841  :         _My_data._Mysize = 0;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+24], 0

; 842  :         _My_data._Myres  = _Small_string_capacity;

	mov	rax, QWORD PTR _My_data$[rsp]
	mov	QWORD PTR [rax+32], 15

; 843  :         _My_data._Activate_SSO_buffer();

	mov	rcx, QWORD PTR _My_data$[rsp]
	call	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
	npad	1

; 844  : 
; 845  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 846  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

	mov	BYTE PTR $T1[rsp], 0
	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR _My_data$[rsp]
	lea	rax, QWORD PTR [rcx+rax+8]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rax
	call	?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Narrow_char_traits<char,int>::assign
	npad	1

; 847  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z
_TEXT	SEGMENT
_Al$ = 48
_Old_ptr$ = 56
_Capacity$ = 64
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 831  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 832  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 833  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

	mov	rax, QWORD PTR _Capacity$[rsp]
	inc	rax
	mov	r8, rax
	mov	rdx, QWORD PTR _Old_ptr$[rsp]
	mov	rcx, QWORD PTR _Al$[rsp]
	call	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
	npad	1

; 834  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAEAV?$allocator@D@2@QEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
tv69 = 40
this$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 689  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR tv69[rsp], rax
	movzx	edx, BYTE PTR $T1[rsp]
	mov	rcx, QWORD PTR tv69[rsp]
	call	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
	npad	1

; 690  :         _Construct_empty();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
	npad	1

; 691  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 56					; 00000038H
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Idx$1 = 32
this$ = 64
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 482  :             _STD _Destroy_in_place(_Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, rax
	call	??$_Destroy_in_place@PEAD@std@@YAXAEAPEAD@Z ; std::_Destroy_in_place<char *>
	npad	1

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Switch_to_

; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@Switch_to_
$LN2@Switch_to_:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@Switch_to_:
	cmp	QWORD PTR _Idx$1[rsp], 16
	jae	SHORT $LN5@Switch_to_

; 488  :                     _Buf[_Idx] = value_type();

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax], 0

; 489  :                 }

	jmp	SHORT $LN2@Switch_to_
$LN5@Switch_to_:

; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

	add	rsp, 56					; 00000038H
	ret	0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

	mov	QWORD PTR [rsp+8], rcx
	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 16
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	mov	rdi, QWORD PTR this$[rsp]
	xor	eax, eax
	mov	ecx, 16
	rep stosb
	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Idx$1 = 32
this$ = 64
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@Activate_S

; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@Activate_S
$LN2@Activate_S:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@Activate_S:
	cmp	QWORD PTR _Idx$1[rsp], 16
	jae	SHORT $LN5@Activate_S

; 442  :                 _Bx._Buf[_Idx] = value_type();

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	BYTE PTR [rax+8], 0

; 443  :             }

	jmp	SHORT $LN2@Activate_S
$LN5@Activate_S:

; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
tv66 = 0
this$ = 32
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 434  :         return _Myres > _Small_string_capacity;

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+32], 15
	jbe	SHORT $LN3@Large_mode
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@Large_mode
$LN3@Large_mode:
	mov	DWORD PTR tv66[rsp], 0
$LN4@Large_mode:
	movzx	eax, BYTE PTR tv66[rsp]

; 435  :     }

	add	rsp, 24
	ret	0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 425  :         const value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR _Result$[rsp], rax

; 426  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 431  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
_Result$ = 32
this$ = 64
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 416  :         value_type* _Result = _Bx._Buf;

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	QWORD PTR _Result$[rsp], rax

; 417  :         if (_Large_mode_engaged()) {

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rax+8]
	call	??$_Unfancy@D@std@@YAPEADPEAD@Z		; std::_Unfancy<char>
	mov	QWORD PTR _Result$[rsp], rax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

	mov	rax, QWORD PTR _Result$[rsp]

; 422  :     }

	add	rsp, 56					; 00000038H
	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??0_Container_base12@std@@QEAA@XZ	; std::_Container_base12::_Container_base12
	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+24], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+32], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

	mov	QWORD PTR [rsp+8], rcx

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, -1

; 715  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 952  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 953  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 954  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

	mov	rcx, QWORD PTR _Count$[rsp]
	call	??$_Get_size_of_n@$00@std@@YA_K_K@Z	; std::_Get_size_of_n<1>
	mov	rcx, rax
	call	??$_Allocate@$0BA@U_Default_allocate_traits@std@@@std@@YAPEAX_K@Z ; std::_Allocate<16,std::_Default_allocate_traits>

; 955  :     }

	add	rsp, 40					; 00000028H
	ret	0
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 946  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

$LN13:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN4@deallocate:

; 947  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

	cmp	QWORD PTR _Ptr$[rsp], 0
	jne	SHORT $LN10@deallocate
	cmp	QWORD PTR _Count$[rsp], 0
	jne	SHORT $LN8@deallocate
$LN10@deallocate:
	jmp	SHORT $LN9@deallocate
$LN8@deallocate:
$LN7@deallocate:
	lea	rax, OFFSET FLAT:??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 947				; 000003b3H
	lea	rdx, OFFSET FLAT:??_C@_0GC@OGIIGPAB@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN12@deallocate
	int	3
	xor	eax, eax
$LN12@deallocate:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 947				; 000003b3H
	lea	r8, OFFSET FLAT:??_C@_1ME@MIFAIHL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
	call	QWORD PTR __imp__invalid_parameter
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@deallocate
$LN9@deallocate:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@deallocate

; 948  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 949  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rdx, QWORD PTR _Count$[rsp]
	mov	rcx, QWORD PTR _Ptr$[rsp]
	call	??$_Deallocate@$0BA@@std@@YAXPEAX_K@Z	; std::_Deallocate<16>
	npad	1

; 950  :     }

	add	rsp, 56					; 00000038H
	ret	0
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 938  :     constexpr allocator() noexcept {}

	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 516  : [[noreturn]] inline void _Xlen_string() {

$LN3:
	sub	rsp, 40					; 00000028H

; 517  :     _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	?_Xlength_error@std@@YAXPEBD@Z		; std::_Xlength_error
	npad	1
$LN2@Xlen_strin:

; 518  : }

	add	rsp, 40					; 00000028H
	ret	0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z
_TEXT	SEGMENT
_Old_val$ = 0
_Val$ = 32
_New_val$ = 40
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 751  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 752  :     // assign _New_val to _Val, return previous _Val
; 753  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Old_val$[rsp], rax

; 754  :     _Val         = static_cast<_Other&&>(_New_val);

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rcx, QWORD PTR _New_val$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	QWORD PTR [rax], rcx

; 755  :     return _Old_val;

	mov	rax, QWORD PTR _Old_val$[rsp]

; 756  : }

	add	rsp, 24
	ret	0
??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Lock$ = 32
this$ = 64
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT

; 1205 :     void _Orphan_all_locked_v3() noexcept {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1206 :         _Lockit _Lock(_LOCK_DEBUG);

	mov	edx, 3
	lea	rcx, QWORD PTR _Lock$[rsp]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 1207 :         _Orphan_all_unlocked_v3();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1208 :     }

	lea	rcx, QWORD PTR _Lock$[rsp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	npad	1
	add	rsp, 56					; 00000038H
	ret	0
?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ
_TEXT	SEGMENT
_Pnext$1 = 32
$T2 = 40
this$ = 64
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT

; 1345 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1346 :     if (!_Myproxy) { // no proxy, already done

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@Orphan_all

; 1347 :         return;

	jmp	SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1348 :     }
; 1349 : 
; 1350 :     // proxy allocated, drain it
; 1351 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

	mov	QWORD PTR $T2[rsp], 0
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 8
	lea	rdx, QWORD PTR $T2[rsp]
	mov	rcx, rax
	call	??$exchange@PEAU_Iterator_base12@std@@$$T@std@@YAPEAU_Iterator_base12@0@AEAPEAU10@$$QEA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
	mov	QWORD PTR _Pnext$1[rsp], rax
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:
	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR _Pnext$1[rsp], rax
$LN4@Orphan_all:
	cmp	QWORD PTR _Pnext$1[rsp], 0
	je	SHORT $LN1@Orphan_all

; 1352 :         _Pnext->_Myproxy = nullptr;

	mov	rax, QWORD PTR _Pnext$1[rsp]
	mov	QWORD PTR [rax], 0

; 1353 :     }

	jmp	SHORT $LN2@Orphan_all
$LN1@Orphan_all:

; 1354 : }

	add	rsp, 56					; 00000038H
	ret	0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 1356 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1357 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1358 : #if _HAS_CXX20
; 1359 :     if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@Orphan_all

; 1360 :         _Orphan_all_unlocked_v3();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_all_unlocked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
	npad	1

; 1361 :     } else

	jmp	SHORT $LN3@Orphan_all
$LN2@Orphan_all:

; 1362 : #endif // _HAS_CXX20
; 1363 :     {
; 1364 :         _Orphan_all_locked_v3();

	mov	rcx, QWORD PTR this$[rsp]
	call	?_Orphan_all_locked_v3@_Container_base12@std@@AEAAXXZ ; std::_Container_base12::_Orphan_all_locked_v3
	npad	1
$LN3@Orphan_all:

; 1365 :     }
; 1366 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1367 : }

	add	rsp, 40					; 00000028H
	ret	0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 1174 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	mov	QWORD PTR [rsp+8], rcx

; 1175 : 
; 1176 :     _Container_base12(const _Container_base12&)            = delete;
; 1177 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1178 : 
; 1179 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1180 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1181 : 
; 1182 :     template <class _Alloc>
; 1183 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1184 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1185 :         _Construct_in_place(*_New_proxy, this);
; 1186 :         _Myproxy            = _New_proxy;
; 1187 :         _New_proxy->_Mycont = this;
; 1188 :     }
; 1189 : 
; 1190 :     template <class _Alloc>
; 1191 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1192 :         // pre: no iterators refer to the existing proxy
; 1193 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1194 :         _Construct_in_place(*_New_proxy, this);
; 1195 :         _New_proxy->_Mycont = this;
; 1196 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1197 :     }
; 1198 : 
; 1199 :     _Container_proxy* _Myproxy = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax], 0

; 1174 :     _CONSTEXPR20 _Container_base12() noexcept = default;

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z
_TEXT	SEGMENT
this$ = 8
_Mycont_$ = 16
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT

; 1166 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Mycont_$[rsp]
	mov	QWORD PTR [rax], rcx

; 1167 : 
; 1168 :     const _Container_base12* _Mycont       = nullptr;
; 1169 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

	mov	rax, QWORD PTR this$[rsp]
	mov	QWORD PTR [rax+8], 0

; 1166 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0_Container_proxy@std@@QEAA@PEAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z
_TEXT	SEGMENT
_Ptr_user$ = 48
_Back_shift$ = 56
_Ptr_container$ = 64
_Min_back_shift$ = 72
_Ptr$ = 96
_Bytes$ = 104
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 169  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

$LN21:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 170  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 171  :     _Bytes += _Non_user_size;

	mov	rax, QWORD PTR _Bytes$[rsp]
	mov	rax, QWORD PTR [rax]
	add	rax, 47					; 0000002fH
	mov	rcx, QWORD PTR _Bytes$[rsp]
	mov	QWORD PTR [rcx], rax

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR _Ptr_user$[rsp], rax

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	eax, 8
	imul	rax, rax, -1
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR _Ptr_container$[rsp], rax
$LN4@Adjust_man:

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

	mov	eax, 8
	imul	rax, rax, -2
	mov	rcx, QWORD PTR _Ptr_user$[rsp]
	mov	rdx, -361700864190383366		; fafafafafafafafaH
	cmp	QWORD PTR [rcx+rax], rdx
	jne	SHORT $LN14@Adjust_man
	jmp	SHORT $LN15@Adjust_man
$LN14@Adjust_man:
$LN7@Adjust_man:
	lea	rax, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 178				; 000000b2H
	lea	rdx, OFFSET FLAT:??_C@_0GC@OGIIGPAB@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN19@Adjust_man
	int	3
	xor	eax, eax
$LN19@Adjust_man:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 178				; 000000b2H
	lea	r8, OFFSET FLAT:??_C@_1ME@MIFAIHL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	QWORD PTR __imp__invalid_parameter
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN7@Adjust_man
$LN15@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	$LN4@Adjust_man

; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

	mov	QWORD PTR _Min_back_shift$[rsp], 16

; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR _Back_shift$[rsp], rax
$LN10@Adjust_man:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	cmp	QWORD PTR _Back_shift$[rsp], 16
	jb	SHORT $LN16@Adjust_man
	cmp	QWORD PTR _Back_shift$[rsp], 47		; 0000002fH
	ja	SHORT $LN16@Adjust_man
	jmp	SHORT $LN17@Adjust_man
$LN16@Adjust_man:
$LN13@Adjust_man:
	lea	rax, OFFSET FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
	mov	QWORD PTR [rsp+32], rax
	xor	r9d, r9d
	mov	r8d, 188				; 000000bcH
	lea	rdx, OFFSET FLAT:??_C@_0GC@OGIIGPAB@C?3?2Program?5Files?2Microsoft?5Visu@
	mov	ecx, 2
	call	QWORD PTR __imp__CrtDbgReport
	cmp	eax, 1
	jne	SHORT $LN20@Adjust_man
	int	3
	xor	eax, eax
$LN20@Adjust_man:
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 188				; 000000bcH
	lea	r8, OFFSET FLAT:??_C@_1ME@MIFAIHL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	lea	rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
	lea	rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	call	QWORD PTR __imp__invalid_parameter
	npad	1
	xor	eax, eax
	test	eax, eax
	jne	SHORT $LN13@Adjust_man
$LN17@Adjust_man:
	xor	eax, eax
	test	eax, eax
	jne	$LN10@Adjust_man

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, QWORD PTR _Ptr$[rsp]
	mov	rcx, QWORD PTR _Ptr_container$[rsp]
	mov	QWORD PTR [rax], rcx

; 190  : }

	add	rsp, 88					; 00000058H
	ret	0
?_Adjust_manually_vector_aligned@std@@YAXAEAPEAXAEA_K@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z
_TEXT	SEGMENT
_Bytes$ = 48
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z PROC ; std::_Default_allocate_traits::_Allocate, COMDAT

; 100  :         void* _Allocate(const size_t _Bytes) {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 101  :         return ::operator new(_Bytes);

	mov	rcx, QWORD PTR _Bytes$[rsp]
	call	??2@YAPEAX_K@Z				; operator new

; 102  :     }

	add	rsp, 40					; 00000028H
	ret	0
?_Allocate@_Default_allocate_traits@std@@SAPEAX_K@Z ENDP ; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 74   : [[noreturn]] inline void _Throw_bad_array_new_length() {

$LN3:
	sub	rsp, 72					; 00000048H

; 75   :     _THROW(bad_array_new_length{});

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_array_new_length@std@@QEAA@XZ	; std::bad_array_new_length::bad_array_new_length
	lea	rdx, OFFSET FLAT:_TI3?AVbad_array_new_length@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	npad	1
$LN2@Throw_bad_:

; 76   : }

	add	rsp, 72					; 00000048H
	ret	0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_array_new_length@std@@UEAAPEAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_array_new_length@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_array_new_length@std@@UEAAPEAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_array_new_length@std@@QEAA@AEBV01@@Z PROC	; std::bad_array_new_length::bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@QEAA@AEBV01@@Z
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@AEBV01@@Z ENDP	; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_array_new_length@std@@UEAA@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_array_new_length@std@@UEAA@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0bad_array_new_length@std@@QEAA@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT

; 144  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 143  :         : bad_alloc("bad array new length")

	lea	rdx, OFFSET FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	mov	rcx, QWORD PTR this$[rsp]
	call	??0bad_alloc@std@@AEAA@QEBD@Z		; std::bad_alloc::bad_alloc

; 144  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_array_new_length@std@@6B@
	mov	QWORD PTR [rax], rcx

; 145  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_array_new_length@std@@QEAA@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_alloc@std@@UEAAPEAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1bad_alloc@std@@UEAA@XZ
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gbad_alloc@std@@UEAAPEAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_alloc@std@@QEAA@AEBV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rdx, QWORD PTR __that$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@AEBV01@@Z	; std::exception::exception
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@QEAA@AEBV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1bad_alloc@std@@UEAA@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	npad	1
	add	rsp, 40					; 00000028H
	ret	0
??1bad_alloc@std@@UEAA@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Message$ = 56
??0bad_alloc@std@@AEAA@QEBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT

; 133  :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 132  :         : exception(_Message, 1)

	mov	r8d, 1
	mov	rdx, QWORD PTR _Message$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	??0exception@std@@QEAA@QEBDH@Z		; std::exception::exception

; 133  :     {

	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7bad_alloc@std@@6B@
	mov	QWORD PTR [rax], rcx

; 134  :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??0bad_alloc@std@@AEAA@QEBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN5:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rcx, QWORD PTR this$[rsp]
	call	??1exception@std@@UEAA@XZ		; std::exception::~exception
	mov	eax, DWORD PTR __flags$[rsp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN2@scalar
	mov	edx, 24
	mov	rcx, QWORD PTR this$[rsp]
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN2@scalar:
	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 40					; 00000028H
	ret	0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
tv69 = 0
this$ = 32
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 95   :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR this$[rsp]
	cmp	QWORD PTR [rax+8], 0
	je	SHORT $LN3@what
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR tv69[rsp], rax
	jmp	SHORT $LN4@what
$LN3@what:
	lea	rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	mov	QWORD PTR tv69[rsp], rax
$LN4@what:
	mov	rax, QWORD PTR tv69[rsp]

; 97   :     }

	add	rsp, 24
	ret	0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 90   :     {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 91   :         __std_exception_destroy(&_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, rax
	call	__std_exception_destroy
	npad	1

; 92   :     }

	add	rsp, 40					; 00000028H
	ret	0
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 73   :     {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 72   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rcx, QWORD PTR _Other$[rsp]
	add	rcx, 8
	mov	rdx, rax
	call	__std_exception_copy
	npad	1

; 75   :     }

	mov	rax, QWORD PTR this$[rsp]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 16
_Message$ = 24
__formal$ = 32
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 67   :     {

$LN4:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	mov	rax, QWORD PTR this$[rsp]
	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rax], rcx

; 66   :         : _Data()

	mov	rax, QWORD PTR this$[rsp]
	add	rax, 8
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 68   :         _Data._What = _Message;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR _Message$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 69   :     }

	mov	rax, QWORD PTR this$[rsp]
	pop	rdi
	ret	0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z PROC ; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 417  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 418  : #if _HAS_CXX20
; 419  :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@assign

; 420  :             return _Primary_char_traits::assign(_Left, _Right);

	mov	rdx, QWORD PTR _Right$[rsp]
	mov	rcx, QWORD PTR _Left$[rsp]
	call	?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ; std::_Char_traits<char,int>::assign
	npad	1
	jmp	SHORT $LN1@assign
$LN2@assign:

; 421  :         }
; 422  : #endif // _HAS_CXX20
; 423  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl
$LN1@assign:

; 424  :     }

	add	rsp, 40					; 00000028H
	ret	0
?assign@?$_Narrow_char_traits@DH@std@@SAXAEADAEBD@Z ENDP ; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 166  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 167  :         _Left = _Right;

	mov	rax, QWORD PTR _Left$[rsp]
	mov	rcx, QWORD PTR _Right$[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 168  :     }

	ret	0
?assign@?$_Char_traits@DH@std@@SAXAEADAEBD@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_Idx$1 = 32
_First1$ = 64
_First2$ = 72
_Count$ = 80
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 43   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 44   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 45   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 46   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 47   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 48   : #if _HAS_CXX20
; 49   :         if (_STD is_constant_evaluated()) {

	call	?is_constant_evaluated@std@@YA_NXZ	; std::is_constant_evaluated
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@copy

; 50   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 51   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {

	mov	QWORD PTR _Idx$1[rsp], 0
	jmp	SHORT $LN4@copy
$LN2@copy:
	mov	rax, QWORD PTR _Idx$1[rsp]
	inc	rax
	mov	QWORD PTR _Idx$1[rsp], rax
$LN4@copy:
	mov	rax, QWORD PTR _Count$[rsp]
	cmp	QWORD PTR _Idx$1[rsp], rax
	je	SHORT $LN3@copy

; 52   :                 _First1[_Idx] = _First2[_Idx];

	mov	rax, QWORD PTR _Idx$1[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR _Idx$1[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	add	rdx, rcx
	mov	rcx, rdx
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 53   :             }

	jmp	SHORT $LN2@copy
$LN3@copy:

; 54   : 
; 55   :             return _First1;

	mov	rax, QWORD PTR _First1$[rsp]
	jmp	SHORT $LN1@copy
$LN5@copy:

; 56   :         }
; 57   : #endif // _HAS_CXX20
; 58   : 
; 59   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

	mov	r8, QWORD PTR _Count$[rsp]
	mov	rdx, QWORD PTR _First2$[rsp]
	mov	rcx, QWORD PTR _First1$[rsp]
	call	memcpy

; 60   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 61   : 
; 62   :         return _First1;

	mov	rax, QWORD PTR _First1$[rsp]
$LN1@copy:

; 63   :     }

	add	rsp, 56					; 00000038H
	ret	0
?copy@?$_Char_traits@DH@std@@SAPEADQEADQEBD_K@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 164  :     {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx

; 165  :         (void)_Size;
; 166  :         return _Where;

	mov	rax, QWORD PTR _Where$[rsp]

; 167  :     }

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 183  :     return __builtin_is_constant_evaluated();

	xor	al, al

; 184  : }

	ret	0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 1780 :     }

	add	rsp, 56					; 00000038H
	ret	0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, -1
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsnprintf_l

; 1460 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

	call	__local_stdio_printf_options
	mov	rax, QWORD PTR [rax]
	or	rax, 1
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, QWORD PTR _BufferCount$[rsp]
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp___stdio_common_vsprintf
	mov	DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR _Result$[rsp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[rsp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	eax, DWORD PTR _Result$[rsp]
	mov	DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[rsp]

; 1397 :     }

	add	rsp, 72					; 00000048H
	ret	0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
tv77 = 48
tv75 = 56
_Format$ = 80
printf	PROC						; COMDAT

; 956  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 72					; 00000048H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	QWORD PTR tv75[rsp], rax
	mov	r9, QWORD PTR tv77[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 963  :     }

	add	rsp, 72					; 00000048H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
