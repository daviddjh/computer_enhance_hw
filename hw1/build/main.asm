; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34123.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG44840 DB	'(os_debug_print) Error: string size is more than 500 cha'
	DB	'racters. Printing first 500.', 0aH, 00H
	ORG $+2
$SG44902 DB	'open_file failed to create file handle! last error: %u', 00H
	ORG $+1
$SG44904 DB	'open_file failed to get file size! last error: %u', 00H
	ORG $+6
$SG44919 DB	'close_file failed!', 00H
	ORG $+1
$SG44983 DB	'r', 00H
	ORG $+2
$SG44984 DB	'..\..\computer_enhance\perfaware\part1\listing_0038_many'
	DB	'_register_mov', 00H
	ORG $+2
$SG44986 DB	'mov ', 00H
	ORG $+3
$SG44990 DB	'%.*s, %.*s', 0aH, 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z ; d_std::d_string::c_str
PUBLIC	?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z ; d_std::string_from_lit_string
PUBLIC	?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ ; d_std::format_lit_string
PUBLIC	?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ; d_std::_format_lit_string
PUBLIC	?os_reserve_memory@d_std@@YA_K_K@Z		; d_std::os_reserve_memory
PUBLIC	?os_commit_memory@d_std@@YAX_K0@Z		; d_std::os_commit_memory
PUBLIC	?os_decommit_memory@d_std@@YAX_K0@Z		; d_std::os_decommit_memory
PUBLIC	?os_release_memory@d_std@@YAX_K@Z		; d_std::os_release_memory
PUBLIC	?os_debug_print@d_std@@YAXPEBD@Z		; d_std::os_debug_print
PUBLIC	?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ ; d_std::os_debug_printf
PUBLIC	?os_debug_print@d_std@@YAXUd_string@1@@Z	; d_std::os_debug_print
PUBLIC	?is_debugger_present@d_std@@YA_NXZ		; d_std::is_debugger_present
PUBLIC	?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z	; d_std::open_file
PUBLIC	?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z ; d_std::read_file
PUBLIC	?close_file@d_std@@YA_NUFile@1@@Z		; d_std::close_file
PUBLIC	?release@Memory_Arena@d_std@@QEAAXXZ		; d_std::Memory_Arena::release
PUBLIC	?reset@Memory_Arena@d_std@@QEAAXXZ		; d_std::Memory_Arena::reset
PUBLIC	?allocate@Memory_Arena@d_std@@QEAA_K_K@Z	; d_std::Memory_Arena::allocate
PUBLIC	?deallocate@Memory_Arena@d_std@@QEAAX_K@Z	; d_std::Memory_Arena::deallocate
PUBLIC	?push@Memory_Arena@d_std@@QEAA_K_K@Z		; d_std::Memory_Arena::push
PUBLIC	?pop_to@Memory_Arena@d_std@@QEAAX_K@Z		; d_std::Memory_Arena::pop_to
PUBLIC	?pop_all@Memory_Arena@d_std@@QEAAXXZ		; d_std::Memory_Arena::pop_all
PUBLIC	?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ	; d_std::make_arena
PUBLIC	?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z	; d_std::make_arena
PUBLIC	?murmur3_32@d_std@@YAIPEAXII@Z			; d_std::murmur3_32
PUBLIC	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
PUBLIC	?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z	; d_std::_format_lit_string
PUBLIC	??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ; d_std::Memory_Arena::deallocate_array<char>
PUBLIC	?os_debug_printf@d_std@@YAXPEBDZZ		; d_std::os_debug_printf
PUBLIC	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
PUBLIC	main
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@3ee4f8b588e368f1
PUBLIC	__real@408f400000000000
PUBLIC	__real@43e0000000000000
PUBLIC	__real@bff0000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	memcpy:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSize:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+105
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+137
	DD	imagerel $unwind$?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z
$pdata$?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z DD imagerel $LN8
	DD	imagerel $LN8+211
	DD	imagerel $unwind$?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z
$pdata$?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ
$pdata$?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z DD imagerel $LN56
	DD	imagerel $LN56+2937
	DD	imagerel $unwind$?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z
$pdata$?os_reserve_memory@d_std@@YA_K_K@Z DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$?os_reserve_memory@d_std@@YA_K_K@Z
$pdata$?os_commit_memory@d_std@@YAX_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$?os_commit_memory@d_std@@YAX_K0@Z
$pdata$?os_decommit_memory@d_std@@YAX_K0@Z DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$?os_decommit_memory@d_std@@YAX_K0@Z
$pdata$?os_release_memory@d_std@@YAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?os_release_memory@d_std@@YAX_K@Z
$pdata$?os_debug_print@d_std@@YAXPEBD@Z DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$?os_debug_print@d_std@@YAXPEBD@Z
$pdata$?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ DD imagerel $LN5
	DD	imagerel $LN5+215
	DD	imagerel $unwind$?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ
$pdata$?os_debug_print@d_std@@YAXUd_string@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+335
	DD	imagerel $unwind$?os_debug_print@d_std@@YAXUd_string@1@@Z
$pdata$?is_debugger_present@d_std@@YA_NXZ DD imagerel $LN5
	DD	imagerel $LN5+36
	DD	imagerel $unwind$?is_debugger_present@d_std@@YA_NXZ
$pdata$?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+372
	DD	imagerel $unwind$?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z
$pdata$?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z DD imagerel $LN4
	DD	imagerel $LN4+204
	DD	imagerel $unwind$?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z
$pdata$?close_file@d_std@@YA_NUFile@1@@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$?close_file@d_std@@YA_NUFile@1@@Z
$pdata$?release@Memory_Arena@d_std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$?release@Memory_Arena@d_std@@QEAAXXZ
$pdata$?reset@Memory_Arena@d_std@@QEAAXXZ DD imagerel $LN6
	DD	imagerel $LN6+46
	DD	imagerel $unwind$?reset@Memory_Arena@d_std@@QEAAXXZ
$pdata$?allocate@Memory_Arena@d_std@@QEAA_K_K@Z DD imagerel $LN6
	DD	imagerel $LN6+74
	DD	imagerel $unwind$?allocate@Memory_Arena@d_std@@QEAA_K_K@Z
$pdata$?deallocate@Memory_Arena@d_std@@QEAAX_K@Z DD imagerel $LN6
	DD	imagerel $LN6+70
	DD	imagerel $unwind$?deallocate@Memory_Arena@d_std@@QEAAX_K@Z
$pdata$?push@Memory_Arena@d_std@@QEAA_K_K@Z DD imagerel $LN8
	DD	imagerel $LN8+356
	DD	imagerel $unwind$?push@Memory_Arena@d_std@@QEAA_K_K@Z
$pdata$?pop_to@Memory_Arena@d_std@@QEAAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+211
	DD	imagerel $unwind$?pop_to@Memory_Arena@d_std@@QEAAX_K@Z
$pdata$?pop_all@Memory_Arena@d_std@@QEAAXXZ DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$?pop_all@Memory_Arena@d_std@@QEAAXXZ
$pdata$?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ DD imagerel $LN3
	DD	imagerel $LN3+29
	DD	imagerel $unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ
$pdata$?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+115
	DD	imagerel $unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z
$pdata$?murmur3_32@d_std@@YAIPEAXII@Z DD imagerel $LN9
	DD	imagerel $LN9+382
	DD	imagerel $unwind$?murmur3_32@d_std@@YAIPEAXII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z DD imagerel $LN55
	DD	imagerel $LN55+2079
	DD	imagerel $unwind$?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z DD imagerel $LN6
	DD	imagerel $LN6+56
	DD	imagerel $unwind$??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?os_debug_printf@d_std@@YAXPEBDZZ DD imagerel $LN5
	DD	imagerel $LN5+187
	DD	imagerel $unwind$?os_debug_printf@d_std@@YAXPEBDZZ
$pdata$?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z DD imagerel $LN34
	DD	imagerel $LN34+940
	DD	imagerel $unwind$?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z
$pdata$main DD	imagerel $LN10
	DD	imagerel $LN10+796
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+18
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@3ee4f8b588e368f1
CONST	SEGMENT
__real@3ee4f8b588e368f1 DQ 03ee4f8b588e368f1r	; 1e-05
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z DD 010e01H
	DD	0420eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?os_debug_printf@d_std@@YAXPEBDZZ
	DD	026H
	DD	0a2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?os_debug_print@d_std@@YAXUd_string@1@@Z
	DD	016H
	DD	0137H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ
	DD	027H
	DD	0bdH
voltbl	ENDS
xdata	SEGMENT
$unwind$?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z DD 010e01H
	DD	0620eH
$unwind$?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z DD 011301H
	DD	06213H
$unwind$?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z DD 041d01H
	DD	017011dH
	DD	060157016H
$unwind$?os_reserve_memory@d_std@@YA_K_K@Z DD 010901H
	DD	06209H
$unwind$?os_commit_memory@d_std@@YAX_K0@Z DD 010e01H
	DD	0420eH
$unwind$?os_decommit_memory@d_std@@YAX_K0@Z DD 010e01H
	DD	0420eH
$unwind$?os_release_memory@d_std@@YAX_K@Z DD 010901H
	DD	04209H
$unwind$?os_debug_print@d_std@@YAXPEBD@Z DD 010901H
	DD	04209H
$unwind$?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ DD 042f19H
	DD	04f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$?os_debug_print@d_std@@YAXUd_string@1@@Z DD 021e19H
	DD	04b010cH
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$?is_debugger_present@d_std@@YA_NXZ DD 010401H
	DD	06204H
$unwind$?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z DD 011301H
	DD	0a213H
$unwind$?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z DD 011801H
	DD	08218H
$unwind$?close_file@d_std@@YA_NUFile@1@@Z DD 010901H
	DD	04209H
$unwind$?release@Memory_Arena@d_std@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?reset@Memory_Arena@d_std@@QEAAXXZ DD 010901H
	DD	06209H
$unwind$?allocate@Memory_Arena@d_std@@QEAA_K_K@Z DD 010e01H
	DD	0620eH
$unwind$?deallocate@Memory_Arena@d_std@@QEAAX_K@Z DD 010e01H
	DD	0620eH
$unwind$?push@Memory_Arena@d_std@@QEAA_K_K@Z DD 010e01H
	DD	0a20eH
$unwind$?pop_to@Memory_Arena@d_std@@QEAAX_K@Z DD 010e01H
	DD	0820eH
$unwind$?pop_all@Memory_Arena@d_std@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ DD 010401H
	DD	06204H
$unwind$?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z DD 010901H
	DD	06209H
$unwind$?murmur3_32@d_std@@YAIPEAXII@Z DD 011201H
	DD	08212H
$unwind$?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z DD 041d01H
	DD	013011dH
	DD	060157016H
$unwind$?os_debug_printf@d_std@@YAXPEBDZZ DD 032e19H
	DD	048011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z DD 011801H
	DD	04218H
$unwind$main DD	040a01H
	DD	02b010aH
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\hw1\main.cpp
_TEXT	SEGMENT
w$1 = 48
d$2 = 49
reg$3 = 50
r_m$4 = 51
i$5 = 52
it$ = 56
mode$6 = 64
success$ = 65
base_arena$ = 72
source_reg$7 = 80
dest_reg$8 = 96
test_file$ = 112
test_file_contents$ = 128
$T9 = 144
$T10 = 160
$T11 = 176
$T12 = 192
$T13 = 208
$T14 = 224
$T15 = 240
$T16 = 256
$T17 = 272
$T18 = 288
$T19 = 304
$T20 = 320
main	PROC

; 82   : int main(){

$LN10:
	push	rsi
	push	rdi
	sub	rsp, 344				; 00000158H

; 83   : 
; 84   :     // Init
; 85   :     Memory_Arena* base_arena = make_arena();

	call	?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ ; d_std::make_arena
	mov	QWORD PTR base_arena$[rsp], rax

; 86   :     File test_file = open_file("..\\..\\computer_enhance\\perfaware\\part1\\listing_0038_many_register_mov", "r"); 

	lea	r8, OFFSET FLAT:$SG44983
	lea	rdx, OFFSET FLAT:$SG44984
	lea	rcx, QWORD PTR $T15[rsp]
	call	?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z ; d_std::open_file
	lea	rcx, QWORD PTR test_file$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 87   :     d_string test_file_contents = read_file(base_arena, test_file, test_file.size);

	lea	rax, QWORD PTR $T9[rsp]
	lea	rcx, QWORD PTR test_file$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	mov	r9d, DWORD PTR test_file$[rsp+8]
	lea	r8, QWORD PTR $T9[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T16[rsp]
	call	?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z ; d_std::read_file
	lea	rcx, QWORD PTR test_file_contents$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 88   : 
; 89   :     // Decode
; 90   :     char* it = test_file_contents.string;

	mov	rax, QWORD PTR test_file_contents$[rsp]
	mov	QWORD PTR it$[rsp], rax

; 91   :     for(int i = 0; i < test_file_contents.size; i++, it++){

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
$LN4@main:
	mov	eax, DWORD PTR test_file_contents$[rsp+8]
	cmp	DWORD PTR i$5[rsp], eax
	jae	$LN3@main

; 92   :         if(*it & 0b10001000){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 136				; 00000088H
	test	eax, eax
	je	$LN5@main

; 93   :             u8 d = (*it & 0b00000010) >> 1;

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 2
	sar	eax, 1
	mov	BYTE PTR d$2[rsp], al

; 94   :             u8 w = *it & 0b00000001;

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 1
	mov	BYTE PTR w$1[rsp], al

; 95   :             it++, i++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax

; 96   :             u8 mode = (*it & 0b11000000) >> 6; 

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 192				; 000000c0H
	sar	eax, 6
	mov	BYTE PTR mode$6[rsp], al

; 97   :             u8 reg  = (*it & 0b00111000) >> 3; 

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 56					; 00000038H
	sar	eax, 3
	mov	BYTE PTR reg$3[rsp], al

; 98   :             u8 r_m  = *it & 0b00000111; 

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	and	eax, 7
	mov	BYTE PTR r_m$4[rsp], al

; 99   :             printf("mov ");

	lea	rcx, OFFSET FLAT:$SG44986
	call	printf
	npad	1

; 100  :             d_string dest_reg; 
; 101  :             d_string source_reg; 
; 102  :             if(d == 0){

	movzx	eax, BYTE PTR d$2[rsp]
	test	eax, eax
	jne	$LN6@main

; 103  :                 dest_reg   = decode_reg(base_arena, r_m, w);

	movzx	r9d, BYTE PTR w$1[rsp]
	movzx	r8d, BYTE PTR r_m$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T10[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_reg$8[rsp]
	lea	rcx, QWORD PTR $T10[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 104  :                 source_reg = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$1[rsp]
	movzx	r8d, BYTE PTR reg$3[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T18[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T11[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_reg$7[rsp]
	lea	rcx, QWORD PTR $T11[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	jmp	$LN7@main
$LN6@main:

; 105  :             } else if (d == 1){

	movzx	eax, BYTE PTR d$2[rsp]
	cmp	eax, 1
	jne	$LN8@main

; 106  :                 dest_reg   = decode_reg(base_arena, reg, w);

	movzx	r9d, BYTE PTR w$1[rsp]
	movzx	r8d, BYTE PTR reg$3[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T19[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T12[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR dest_reg$8[rsp]
	lea	rcx, QWORD PTR $T12[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 107  :                 source_reg = decode_reg(base_arena, r_m, w);

	movzx	r9d, BYTE PTR w$1[rsp]
	movzx	r8d, BYTE PTR r_m$4[rsp]
	mov	rdx, QWORD PTR base_arena$[rsp]
	lea	rcx, QWORD PTR $T20[rsp]
	call	?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ; decode_reg
	lea	rcx, QWORD PTR $T13[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	lea	rax, QWORD PTR source_reg$7[rsp]
	lea	rcx, QWORD PTR $T13[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
$LN8@main:
$LN7@main:

; 108  :             }
; 109  :             printf("%.*s, %.*s\n", dest_reg.size, dest_reg.string, source_reg.size, source_reg.string);

	mov	rax, QWORD PTR source_reg$7[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR source_reg$7[rsp+8]
	mov	r8, QWORD PTR dest_reg$8[rsp]
	mov	edx, DWORD PTR dest_reg$8[rsp+8]
	lea	rcx, OFFSET FLAT:$SG44990
	call	printf
	npad	1
$LN5@main:

; 110  :         }
; 111  :     }

	jmp	$LN2@main
$LN3@main:

; 112  : 
; 113  :     // Destroy
; 114  :     bool success   = close_file(test_file);

	lea	rax, QWORD PTR $T14[rsp]
	lea	rcx, QWORD PTR test_file$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rcx, QWORD PTR $T14[rsp]
	call	?close_file@d_std@@YA_NUFile@1@@Z	; d_std::close_file
	mov	BYTE PTR success$[rsp], al

; 115  :     base_arena->release();

	mov	rcx, QWORD PTR base_arena$[rsp]
	call	?release@Memory_Arena@d_std@@QEAAXXZ	; d_std::Memory_Arena::release
	npad	1

; 116  : }

	xor	eax, eax
	add	rsp, 344				; 00000158H
	pop	rdi
	pop	rsi
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\hw1\main.cpp
_TEXT	SEGMENT
__$ReturnAddress$ = 48
arena$ = 56
reg$ = 64
w$ = 72
?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z PROC ; decode_reg

; 7    : d_string decode_reg(Memory_Arena* arena, u8 reg, u8 w){

$LN34:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 8    :     d_string reg_string;
; 9    :     reg_string.string = arena->allocate_array<char>(2);

	mov	edx, 2
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 10   :     reg_string.size = 2;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], 2

; 11   : 
; 12   :     if(reg == 0b000){

	movzx	eax, BYTE PTR reg$[rsp]
	test	eax, eax
	jne	SHORT $LN2@decode_reg

; 13   : 
; 14   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN4@decode_reg

; 15   :             reg_string.string[0] = 'A';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 65			; 00000041H

; 16   :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 17   :         } else {

	jmp	SHORT $LN5@decode_reg
$LN4@decode_reg:

; 18   :             reg_string.string[0] = 'A';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 65			; 00000041H

; 19   :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN5@decode_reg:

; 20   :         }

	jmp	$LN3@decode_reg
$LN2@decode_reg:

; 21   : 
; 22   :     } else if(reg == 0b001){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 1
	jne	SHORT $LN6@decode_reg

; 23   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN8@decode_reg

; 24   :             reg_string.string[0] = 'C';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 67			; 00000043H

; 25   :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 26   :         } else {

	jmp	SHORT $LN9@decode_reg
$LN8@decode_reg:

; 27   :             reg_string.string[0] = 'C';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 67			; 00000043H

; 28   :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN9@decode_reg:

; 29   :         }

	jmp	$LN7@decode_reg
$LN6@decode_reg:

; 30   :     } else if(reg == 0b010){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 2
	jne	SHORT $LN10@decode_reg

; 31   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN12@decode_reg

; 32   :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 33   :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 34   :         } else {

	jmp	SHORT $LN13@decode_reg
$LN12@decode_reg:

; 35   :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 36   :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN13@decode_reg:

; 37   :         }

	jmp	$LN11@decode_reg
$LN10@decode_reg:

; 38   :     } else if(reg == 0b011){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 3
	jne	SHORT $LN14@decode_reg

; 39   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN16@decode_reg

; 40   :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 41   :             reg_string.string[1] = 'L';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 76			; 0000004cH

; 42   :         } else {

	jmp	SHORT $LN17@decode_reg
$LN16@decode_reg:

; 43   :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 44   :             reg_string.string[1] = 'X';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 88			; 00000058H
$LN17@decode_reg:

; 45   :         }

	jmp	$LN15@decode_reg
$LN14@decode_reg:

; 46   :     } else if(reg == 0b100){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 4
	jne	SHORT $LN18@decode_reg

; 47   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN20@decode_reg

; 48   :             reg_string.string[0] = 'A';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 65			; 00000041H

; 49   :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 50   :         } else {

	jmp	SHORT $LN21@decode_reg
$LN20@decode_reg:

; 51   :             reg_string.string[0] = 'S';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 83			; 00000053H

; 52   :             reg_string.string[1] = 'P';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 80			; 00000050H
$LN21@decode_reg:

; 53   :         }

	jmp	$LN19@decode_reg
$LN18@decode_reg:

; 54   :     } else if(reg == 0b101){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 5
	jne	SHORT $LN22@decode_reg

; 55   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN24@decode_reg

; 56   :             reg_string.string[0] = 'C';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 67			; 00000043H

; 57   :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 58   :         } else {

	jmp	SHORT $LN25@decode_reg
$LN24@decode_reg:

; 59   :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 60   :             reg_string.string[1] = 'P';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 80			; 00000050H
$LN25@decode_reg:

; 61   :         }

	jmp	$LN23@decode_reg
$LN22@decode_reg:

; 62   :     } else if(reg == 0b110){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 6
	jne	SHORT $LN26@decode_reg

; 63   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN28@decode_reg

; 64   :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 65   :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 66   :         } else {

	jmp	SHORT $LN29@decode_reg
$LN28@decode_reg:

; 67   :             reg_string.string[0] = 'S';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 83			; 00000053H

; 68   :             reg_string.string[1] = 'I';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 73			; 00000049H
$LN29@decode_reg:

; 69   :         }

	jmp	SHORT $LN27@decode_reg
$LN26@decode_reg:

; 70   :     } else if(reg == 0b111){

	movzx	eax, BYTE PTR reg$[rsp]
	cmp	eax, 7
	jne	SHORT $LN30@decode_reg

; 71   :         if(w == 0){

	movzx	eax, BYTE PTR w$[rsp]
	test	eax, eax
	jne	SHORT $LN31@decode_reg

; 72   :             reg_string.string[0] = 'B';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 66			; 00000042H

; 73   :             reg_string.string[1] = 'H';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 72			; 00000048H

; 74   :         } else {

	jmp	SHORT $LN32@decode_reg
$LN31@decode_reg:

; 75   :             reg_string.string[0] = 'D';

	mov	eax, 1
	imul	rax, rax, 0
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 68			; 00000044H

; 76   :             reg_string.string[1] = 'I';

	mov	eax, 1
	imul	rax, rax, 1
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rax+rcx], 73			; 00000049H
$LN32@decode_reg:
$LN30@decode_reg:
$LN27@decode_reg:
$LN23@decode_reg:
$LN19@decode_reg:
$LN15@decode_reg:
$LN11@decode_reg:
$LN7@decode_reg:
$LN3@decode_reg:

; 77   :         }
; 78   :     }
; 79   :     return reg_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 80   : }

	add	rsp, 40					; 00000028H
	ret	0
?decode_reg@@YA?AUd_string@d_std@@PEAUMemory_Arena@2@EE@Z ENDP ; decode_reg
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
$T1 = 32
va_args$ = 40
c_str$ = 48
__$ArrayPad$ = 560
lit_string$ = 592
?os_debug_printf@d_std@@YAXPEBDZZ PROC			; d_std::os_debug_printf

; 107  :     void __cdecl os_debug_printf(const char* lit_string, ...){

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	sub	rsp, 576				; 00000240H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 108  : 
; 109  :         // va_list
; 110  :         u_ptr va_args;
; 111  : 
; 112  :         // va_start
; 113  :         va_args = (u_ptr)(&lit_string + 1);

	lea	rax, QWORD PTR lit_string$[rsp+8]
	mov	QWORD PTR va_args$[rsp], rax

; 114  : 
; 115  :         char c_str[501] = {0}; 

	lea	rax, QWORD PTR c_str$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 501				; 000001f5H
	rep stosb

; 116  : 
; 117  :         _format_lit_string(c_str, 500, lit_string, va_args);

	mov	r9, QWORD PTR va_args$[rsp]
	mov	r8, QWORD PTR lit_string$[rsp]
	mov	dx, 500					; 000001f4H
	lea	rcx, QWORD PTR c_str$[rsp]
	call	?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z ; d_std::_format_lit_string
	npad	1

; 118  : 
; 119  :         c_str[500] = '\0';

	mov	eax, 1
	imul	rax, rax, 500				; 000001f4H
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 501			; 000001f5H
	jae	SHORT $LN3@os_debug_p
	jmp	SHORT $LN4@os_debug_p
$LN3@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN4@os_debug_p:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 120  : 
; 121  :         OutputDebugStringA(c_str);

	lea	rcx, QWORD PTR c_str$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1
$LN2@os_debug_p:

; 122  : 
; 123  :         return;
; 124  : 
; 125  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 576				; 00000240H
	pop	rdi
	ret	0
?os_debug_printf@d_std@@YAXPEBDZZ ENDP			; d_std::os_debug_printf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.h
;	COMDAT ??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z
_TEXT	SEGMENT
tv65 = 32
this$ = 64
array$ = 72
??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z PROC ; d_std::Memory_Arena::deallocate_array<char>, COMDAT

; 94   :         inline void deallocate_array(t* array){

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 95   : 
; 96   : 
; 97   :             switch (this->type)

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@deallocate
	jmp	SHORT $LN2@deallocate
$LN4@deallocate:

; 98   :             {
; 99   :             case Memory_Arena_Type_Linear:
; 100  : 
; 101  :                 this->deallocate((u_ptr)array);

	mov	rdx, QWORD PTR array$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?deallocate@Memory_Arena@d_std@@QEAAX_K@Z ; d_std::Memory_Arena::deallocate
	npad	1
$LN2@deallocate:

; 102  :                 break;
; 103  :             
; 104  :             }
; 105  : 
; 106  :         }

	add	rsp, 56					; 00000038H
	ret	0
??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ENDP ; d_std::Memory_Arena::deallocate_array<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
return_string_size$ = 0
size_limit_reached$ = 4
capacity$ = 8
temp$1 = 16
placement_ptr$2 = 24
it$ = 32
temp$3 = 40
placement_ptr$4 = 48
tv87 = 56
i$5 = 60
double_input$6 = 64
input_string_iterator$7 = 72
placement_ptr$8 = 80
placement_ptr$9 = 88
integer_part$10 = 96
number$11 = 104
decimal_part$12 = 112
c_str$13 = 120
d_str$14 = 128
return_string$ = 176
return_string_max_size$ = 184
lit_string$ = 192
va_args$ = 200
?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z PROC	; d_std::_format_lit_string

; 55   :     void __cdecl _format_lit_string(char* return_string, u16 return_string_max_size, const char* lit_string, u_ptr va_args){

$LN55:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	WORD PTR [rsp+16], dx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H

; 56   : 
; 57   :         // it iterates through the original string
; 58   :         const char* it = lit_string;

	mov	rax, QWORD PTR lit_string$[rsp]
	mov	QWORD PTR it$[rsp], rax

; 59   : 
; 60   :         u16 return_string_size = 0;

	xor	eax, eax
	mov	WORD PTR return_string_size$[rsp], ax

; 61   :         u16 capacity = return_string_max_size;

	movzx	eax, WORD PTR return_string_max_size$[rsp]
	mov	WORD PTR capacity$[rsp], ax

; 62   :         bool size_limit_reached = false;

	mov	BYTE PTR size_limit_reached$[rsp], 0
$LN2@format_lit:

; 63   : 
; 64   :         while( *it != '\0' && size_limit_reached == false){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@format_lit
	movzx	eax, BYTE PTR size_limit_reached$[rsp]
	test	eax, eax
	jne	$LN3@format_lit
$LN4@format_lit:

; 65   : 
; 66   :             while( *it != '%' && *it != '\0'){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN5@format_lit
	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN5@format_lit

; 67   :                 return_string[return_string_size] = *it;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	mov	rdx, QWORD PTR it$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl

; 68   :                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 69   :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 70   :                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN31@format_lit

; 71   :                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 72   :                     break;

	jmp	SHORT $LN5@format_lit
$LN31@format_lit:

; 73   :                 }
; 74   :             }

	jmp	SHORT $LN4@format_lit
$LN5@format_lit:

; 75   :             if ( *it == '%' ) {

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN32@format_lit

; 76   :                 if ( *(it+1) != '\0' ){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	$LN33@format_lit

; 77   :                     
; 78   :                     // Switch based on argument type
; 79   :                     switch(*(it+1)){

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR tv87[rsp], al
	cmp	BYTE PTR tv87[rsp], 36			; 00000024H
	je	$LN39@format_lit
	cmp	BYTE PTR tv87[rsp], 102			; 00000066H
	je	$LN41@format_lit
	cmp	BYTE PTR tv87[rsp], 115			; 00000073H
	je	$LN37@format_lit
	cmp	BYTE PTR tv87[rsp], 117			; 00000075H
	je	SHORT $LN34@format_lit
	jmp	$LN6@format_lit
$LN34@format_lit:

; 80   : 
; 81   :                         // Unsigned int
; 82   :                         case('u'):
; 83   :                         {
; 84   :                             u64 number = *(u64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR number$11[rsp], rax

; 85   :                             va_args += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 86   : 
; 87   :                             char* placement_ptr = return_string + return_string_size - 1;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	lea	rax, QWORD PTR [rcx+rax-1]
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 88   : 
; 89   :                             // Guarantee one spot. What if "number" is 0?
; 90   :                             u64 temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 91   :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 92   :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 93   :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN35@format_lit

; 94   :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 95   :                                 break;

	jmp	$LN6@format_lit
$LN35@format_lit:

; 96   :                             }
; 97   :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 98   : 
; 99   :                             // Find the reset of the space this number will take up in the string
; 100  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN10@format_lit
$LN8@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
$LN10@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN9@format_lit

; 101  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 102  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 103  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN36@format_lit

; 104  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 105  :                                     break;

	jmp	SHORT $LN9@format_lit
$LN36@format_lit:

; 106  :                                 }
; 107  :                             }

	jmp	SHORT $LN8@format_lit
$LN9@format_lit:

; 108  : 
; 109  :                             // Insert the numbers from smallest (right) to largest (left)
; 110  :                             temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 111  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 112  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 113  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 114  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN13@format_lit
$LN11@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax
$LN13@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN12@format_lit

; 115  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 116  :                             }

	jmp	SHORT $LN11@format_lit
$LN12@format_lit:

; 117  : 
; 118  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 119  :                         }
; 120  :                         break;

	jmp	$LN6@format_lit
$LN37@format_lit:

; 121  : 
; 122  :                         // C string
; 123  :                         case('s'):
; 124  :                         {
; 125  :                             char* c_str = *(char**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR c_str$13[rsp], rax

; 126  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 127  : 
; 128  :                             char* placement_ptr = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 129  : 
; 130  :                             char* input_string_iterator = (char*)c_str;

	mov	rax, QWORD PTR c_str$13[rsp]
	mov	QWORD PTR input_string_iterator$7[rsp], rax
$LN14@format_lit:

; 131  : 
; 132  :                             while(*input_string_iterator != '\0'){

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN15@format_lit

; 133  : 
; 134  :                                 // Set char in output string 
; 135  :                                 *placement_ptr = *input_string_iterator;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	mov	rcx, QWORD PTR input_string_iterator$7[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 136  : 
; 137  :                                 // Advance Iterators
; 138  :                                 input_string_iterator++;

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	inc	rax
	mov	QWORD PTR input_string_iterator$7[rsp], rax

; 139  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 140  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 141  : 
; 142  :                                 // Possibly allocate more memory
; 143  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN38@format_lit

; 144  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 145  :                                     break;

	jmp	SHORT $LN15@format_lit
$LN38@format_lit:

; 146  :                                 }
; 147  :                             }

	jmp	SHORT $LN14@format_lit
$LN15@format_lit:

; 148  : 
; 149  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 150  :                         }
; 151  :                         break;

	jmp	$LN6@format_lit
$LN39@format_lit:

; 152  : 
; 153  :                         // d_std::d_string
; 154  :                         case('$'):
; 155  :                         {
; 156  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 157  :                             d_string d_str = **(d_string**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	lea	rcx, QWORD PTR d_str$14[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 158  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 159  : 
; 160  :                             char* placement_ptr = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 161  : 
; 162  :                             //char* input_string_iterator = (char*)d_str.string;
; 163  : 
; 164  :                             for(int i = 0; i < d_str.size; i++){

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN18@format_lit
$LN16@format_lit:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN18@format_lit:
	mov	eax, DWORD PTR d_str$14[rsp+8]
	cmp	DWORD PTR i$5[rsp], eax
	jae	SHORT $LN17@format_lit

; 165  : 
; 166  :                                 // Set char in output string 
; 167  :                                 *placement_ptr = d_str.string[i];

	movsxd	rax, DWORD PTR i$5[rsp]
	mov	rcx, QWORD PTR placement_ptr$9[rsp]
	mov	rdx, QWORD PTR d_str$14[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al

; 168  : 
; 169  :                                 // Advance Iterators
; 170  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$9[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 171  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 172  : 
; 173  :                                 // Possibly allocate more memory
; 174  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN40@format_lit

; 175  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 176  :                                     break;

	jmp	SHORT $LN17@format_lit
$LN40@format_lit:

; 177  :                                 }
; 178  :                             }

	jmp	SHORT $LN16@format_lit
$LN17@format_lit:

; 179  : 
; 180  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 181  :                         }
; 182  :                         break;

	jmp	$LN6@format_lit
$LN41@format_lit:

; 183  : 
; 184  :                         // d_std::d_string
; 185  :                         case('f'):
; 186  :                         {
; 187  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 188  :                             double double_input = *(f64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR double_input$6[rsp], xmm0

; 189  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 190  : 
; 191  :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN42@format_lit

; 192  :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 193  :                                 break;

	jmp	$LN6@format_lit
$LN42@format_lit:

; 194  :                             }
; 195  : 
; 196  :                             char* placement_ptr = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 197  : 
; 198  :                             // Check and possibly add sign bit
; 199  :                             if(double_input < 0){

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR double_input$6[rsp]
	jbe	SHORT $LN43@format_lit

; 200  : 
; 201  :                                 // Add negative char in output string
; 202  :                                 *placement_ptr = '-';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 203  : 
; 204  :                                 // Advance Iterators
; 205  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 206  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 207  : 
; 208  :                                 // Possibly allocate more memory
; 209  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN44@format_lit

; 210  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 211  :                                     break;

	jmp	$LN6@format_lit
$LN44@format_lit:

; 212  :                                 }
; 213  : 
; 214  :                                 double_input *= -1;

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	mulsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR double_input$6[rsp], xmm0
$LN43@format_lit:

; 215  : 
; 216  :                             }
; 217  : 
; 218  :                             u64 integer_part = (u64)double_input;

	xor	eax, eax
	movsd	xmm0, QWORD PTR double_input$6[rsp]
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN54@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN54@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN54@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR integer_part$10[rsp], rax

; 219  : 
; 220  :                             // Guarantee one spot. What if "number" is 0?
; 221  :                             u64 temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 222  :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 223  :                             // Possibly allocate more memory
; 224  :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN45@format_lit

; 225  :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 226  :                                 break;

	jmp	$LN6@format_lit
$LN45@format_lit:

; 227  :                             }
; 228  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 229  : 
; 230  :                             // Find the reset of the space this number will take up in the string
; 231  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN21@format_lit
$LN19@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN21@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN20@format_lit

; 232  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 233  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 234  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN46@format_lit

; 235  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 236  :                                     break;

	jmp	SHORT $LN20@format_lit
$LN46@format_lit:

; 237  :                                 }
; 238  :                             }

	jmp	SHORT $LN19@format_lit
$LN20@format_lit:

; 239  : 
; 240  :                             // Insert the numbers from smallest (right) to largest (left)
; 241  :                             temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 242  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 243  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 244  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 245  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN24@format_lit
$LN22@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN24@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN23@format_lit

; 246  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 247  :                             }

	jmp	SHORT $LN22@format_lit
$LN23@format_lit:

; 248  : 
; 249  :                             placement_ptr     = return_string + return_string_size;

	movzx	eax, WORD PTR return_string_size$[rsp]
	mov	rcx, QWORD PTR return_string$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 250  : 
; 251  :                             // Insert decimal place
; 252  :                             *placement_ptr = '.';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 253  : 
; 254  :                             // Advance Iterators
; 255  :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 256  :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 257  : 
; 258  :                             // Possibly allocate more memory
; 259  :                             if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN47@format_lit

; 260  :                                 size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 261  :                                 break;

	jmp	$LN6@format_lit
$LN47@format_lit:

; 262  :                             }
; 263  : 
; 264  :                             u64 decimal_part = (((double_input + 0.00001 )- (float)integer_part) * 1000.);

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	addsd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	mov	rax, QWORD PTR integer_part$10[rsp]
	test	rax, rax
	jl	SHORT $LN52@format_lit
	cvtsi2ss xmm1, rax
	jmp	SHORT $LN53@format_lit
$LN52@format_lit:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
$LN53@format_lit:
	cvtss2sd xmm1, xmm1
	subsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN51@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN51@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN51@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR decimal_part$12[rsp], rax

; 265  : 
; 266  :                             // Guarantee one spot. What if "number" is 0?
; 267  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 268  :                             return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 269  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 270  : 
; 271  :                             // Find the reset of the space this number will take up in the string
; 272  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN27@format_lit
$LN25@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN27@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN26@format_lit

; 273  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 274  :                                 return_string_size++;

	movzx	eax, WORD PTR return_string_size$[rsp]
	inc	ax
	mov	WORD PTR return_string_size$[rsp], ax

; 275  :                                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN48@format_lit

; 276  :                                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 277  :                                     break;

	jmp	SHORT $LN26@format_lit
$LN48@format_lit:

; 278  :                                 }
; 279  :                             }

	jmp	SHORT $LN25@format_lit
$LN26@format_lit:

; 280  : 
; 281  :                             // Insert the numbers from smallest (right) to largest (left)
; 282  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 283  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 284  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 285  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 286  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN30@format_lit
$LN28@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN30@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN29@format_lit

; 287  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 288  :                             }

	jmp	SHORT $LN28@format_lit
$LN29@format_lit:

; 289  : 
; 290  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
$LN6@format_lit:
$LN33@format_lit:

; 291  :                         }
; 292  :                         break;
; 293  :                     }
; 294  :                 }
; 295  :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 296  :                 if(return_string_size == capacity){

	movzx	eax, WORD PTR return_string_size$[rsp]
	movzx	ecx, WORD PTR capacity$[rsp]
	cmp	eax, ecx
	jne	SHORT $LN49@format_lit

; 297  :                     size_limit_reached = true;

	mov	BYTE PTR size_limit_reached$[rsp], 1

; 298  :                     break;

	jmp	SHORT $LN3@format_lit
$LN49@format_lit:
$LN32@format_lit:

; 299  :                 }
; 300  :             }
; 301  : 
; 302  :         }

	jmp	$LN2@format_lit
$LN3@format_lit:

; 303  : 
; 304  :         return;
; 305  : 
; 306  :     }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
?_format_lit_string@d_std@@YAXPEADGPEBD_K@Z ENDP	; d_std::_format_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.h
;	COMDAT ??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
nitems$ = 56
??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z PROC ; d_std::Memory_Arena::allocate_array<char>, COMDAT

; 87   :         inline t* allocate_array(u64 nitems){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 88   : 
; 89   :             return (t*)allocate(nitems * sizeof(t));

	mov	rdx, QWORD PTR nitems$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?allocate@Memory_Arena@d_std@@QEAA_K_K@Z ; d_std::Memory_Arena::allocate

; 90   : 
; 91   :         }

	add	rsp, 40					; 00000028H
	ret	0
??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ENDP ; d_std::Memory_Arena::allocate_array<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_hash.h
_TEXT	SEGMENT
h$ = 32
k$ = 36
i$1 = 40
key_u8$ = 48
i$2 = 56
key$ = 80
len$ = 88
seed$ = 96
?murmur3_32@d_std@@YAIPEAXII@Z PROC			; d_std::murmur3_32

; 18   :     u32 murmur3_32(void* key, u32 len, u32 seed = 0){

$LN9:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 19   :         u32 h = seed;

	mov	eax, DWORD PTR seed$[rsp]
	mov	DWORD PTR h$[rsp], eax

; 20   :         u32 k;
; 21   :         u8* key_u8 = (u8*)key;

	mov	rax, QWORD PTR key$[rsp]
	mov	QWORD PTR key_u8$[rsp], rax

; 22   : 
; 23   :         // For each 4 bytes in key_u8
; 24   :         for(size_t i = len >> 2; i != 0; i--){

	mov	eax, DWORD PTR len$[rsp]
	shr	eax, 2
	mov	eax, eax
	mov	QWORD PTR i$2[rsp], rax
	jmp	SHORT $LN4@murmur3_32
$LN2@murmur3_32:
	mov	rax, QWORD PTR i$2[rsp]
	dec	rax
	mov	QWORD PTR i$2[rsp], rax
$LN4@murmur3_32:
	cmp	QWORD PTR i$2[rsp], 0
	je	SHORT $LN3@murmur3_32

; 25   :             // Copy 4 bytes to k
; 26   :             memcpy(&k, key_u8, sizeof(u32));

	mov	r8d, 4
	mov	rdx, QWORD PTR key_u8$[rsp]
	lea	rcx, QWORD PTR k$[rsp]
	call	memcpy

; 27   :             // Move key_u8 to next 4 bytes
; 28   :             key_u8 += sizeof(u32);

	mov	rax, QWORD PTR key_u8$[rsp]
	add	rax, 4
	mov	QWORD PTR key_u8$[rsp], rax

; 29   :             h ^= murmur3_scramble_32(k);

	mov	ecx, DWORD PTR k$[rsp]
	call	?murmur3_scramble_32@d_std@@YAII@Z	; d_std::murmur3_scramble_32
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 30   :             h = (h << 13) | (h >> 19);

	mov	eax, DWORD PTR h$[rsp]
	shl	eax, 13
	mov	ecx, DWORD PTR h$[rsp]
	shr	ecx, 19
	or	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 31   :             h = h * 5 + 0xe6546b64;

	imul	eax, DWORD PTR h$[rsp], 5
	add	eax, -430675100				; e6546b64H
	mov	DWORD PTR h$[rsp], eax

; 32   :         }

	jmp	SHORT $LN2@murmur3_32
$LN3@murmur3_32:

; 33   : 
; 34   :         // Deal with the remaining bytes
; 35   :         k = 0;

	mov	DWORD PTR k$[rsp], 0

; 36   :         for(size_t i = len & 3; i != 0; i--){

	mov	eax, DWORD PTR len$[rsp]
	and	eax, 3
	mov	eax, eax
	mov	QWORD PTR i$1[rsp], rax
	jmp	SHORT $LN7@murmur3_32
$LN5@murmur3_32:
	mov	rax, QWORD PTR i$1[rsp]
	dec	rax
	mov	QWORD PTR i$1[rsp], rax
$LN7@murmur3_32:
	cmp	QWORD PTR i$1[rsp], 0
	je	SHORT $LN6@murmur3_32

; 37   :             k <<= 8;

	mov	eax, DWORD PTR k$[rsp]
	shl	eax, 8
	mov	DWORD PTR k$[rsp], eax

; 38   :             k |= key_u8[i - 1];

	mov	rax, QWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR key_u8$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax-1]
	mov	ecx, DWORD PTR k$[rsp]
	or	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR k$[rsp], eax

; 39   :         }

	jmp	SHORT $LN5@murmur3_32
$LN6@murmur3_32:

; 40   : 
; 41   :         h ^= murmur3_scramble_32(k);

	mov	ecx, DWORD PTR k$[rsp]
	call	?murmur3_scramble_32@d_std@@YAII@Z	; d_std::murmur3_scramble_32
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 42   :         h ^= len;

	mov	eax, DWORD PTR len$[rsp]
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 43   :         h ^= h >> 16;

	mov	eax, DWORD PTR h$[rsp]
	shr	eax, 16
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 44   :         h *= 0x85ebca6b;

	imul	eax, DWORD PTR h$[rsp], -2048144789	; 85ebca6bH
	mov	DWORD PTR h$[rsp], eax

; 45   :         h ^= h >> 13;

	mov	eax, DWORD PTR h$[rsp]
	shr	eax, 13
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 46   :         h *= 0xc2b2ae35;

	imul	eax, DWORD PTR h$[rsp], -1028477387	; c2b2ae35H
	mov	DWORD PTR h$[rsp], eax

; 47   :         h ^= h >> 16;

	mov	eax, DWORD PTR h$[rsp]
	shr	eax, 16
	mov	ecx, DWORD PTR h$[rsp]
	xor	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR h$[rsp], eax

; 48   :         return h;

	mov	eax, DWORD PTR h$[rsp]

; 49   :     }

	add	rsp, 72					; 00000048H
	ret	0
?murmur3_32@d_std@@YAIPEAXII@Z ENDP			; d_std::murmur3_32
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_hash.h
_TEXT	SEGMENT
key_4_bytes$ = 8
?murmur3_scramble_32@d_std@@YAII@Z PROC			; d_std::murmur3_scramble_32

; 11   :     static inline u32 murmur3_scramble_32(u32 key_4_bytes){

	mov	DWORD PTR [rsp+8], ecx

; 12   :         key_4_bytes *= 0xcc9e2d51;

	imul	eax, DWORD PTR key_4_bytes$[rsp], -862048943 ; cc9e2d51H
	mov	DWORD PTR key_4_bytes$[rsp], eax

; 13   :         key_4_bytes = (key_4_bytes << 15) | (key_4_bytes >> 17);

	mov	eax, DWORD PTR key_4_bytes$[rsp]
	shl	eax, 15
	mov	ecx, DWORD PTR key_4_bytes$[rsp]
	shr	ecx, 17
	or	eax, ecx
	mov	DWORD PTR key_4_bytes$[rsp], eax

; 14   :         key_4_bytes *= 0x1b873593;

	imul	eax, DWORD PTR key_4_bytes$[rsp], 461845907 ; 1b873593H
	mov	DWORD PTR key_4_bytes$[rsp], eax

; 15   :         return key_4_bytes;

	mov	eax, DWORD PTR key_4_bytes$[rsp]

; 16   :     }

	ret	0
?murmur3_scramble_32@d_std@@YAII@Z ENDP			; d_std::murmur3_scramble_32
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
arena$ = 32
memory$1 = 40
reserve_size$ = 64
?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z PROC	; d_std::make_arena

; 6    :     Memory_Arena* make_arena(u64 reserve_size) {

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 7    :         Memory_Arena* arena = nullptr;

	mov	QWORD PTR arena$[rsp], 0

; 8    : 
; 9    :         if(reserve_size > sizeof(Memory_Arena)){

	cmp	QWORD PTR reserve_size$[rsp], 32	; 00000020H
	jbe	SHORT $LN2@make_arena

; 10   :             u_ptr memory = d_reserve(reserve_size);

	mov	rcx, QWORD PTR reserve_size$[rsp]
	call	?os_reserve_memory@d_std@@YA_K_K@Z	; d_std::os_reserve_memory
	mov	QWORD PTR memory$1[rsp], rax

; 11   :             d_commit(memory, sizeof(Memory_Arena));

	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR memory$1[rsp]
	call	?os_commit_memory@d_std@@YAX_K0@Z	; d_std::os_commit_memory

; 12   :             arena = (Memory_Arena*) memory;

	mov	rax, QWORD PTR memory$1[rsp]
	mov	QWORD PTR arena$[rsp], rax

; 13   : 
; 14   :             arena->capacity = reserve_size;

	mov	rax, QWORD PTR arena$[rsp]
	mov	rcx, QWORD PTR reserve_size$[rsp]
	mov	QWORD PTR [rax], rcx

; 15   :             arena->position = sizeof(Memory_Arena);

	mov	rax, QWORD PTR arena$[rsp]
	mov	QWORD PTR [rax+8], 32			; 00000020H

; 16   :             arena->commit_position = sizeof(Memory_Arena);

	mov	rax, QWORD PTR arena$[rsp]
	mov	QWORD PTR [rax+16], 32			; 00000020H
$LN2@make_arena:

; 17   :         }
; 18   : 
; 19   :         return arena;

	mov	rax, QWORD PTR arena$[rsp]

; 20   :     }

	add	rsp, 56					; 00000038H
	ret	0
?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z ENDP	; d_std::make_arena
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
arena$ = 32
?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ PROC		; d_std::make_arena

; 22   :     Memory_Arena* make_arena() {

$LN3:
	sub	rsp, 56					; 00000038H

; 23   :         Memory_Arena* arena = make_arena(DEFAULT_ARENA_RESERVE_SIZE);

	mov	ecx, 671088640				; 28000000H
	call	?make_arena@d_std@@YAPEAUMemory_Arena@1@_K@Z ; d_std::make_arena
	mov	QWORD PTR arena$[rsp], rax

; 24   :         return arena;

	mov	rax, QWORD PTR arena$[rsp]

; 25   :     }

	add	rsp, 56					; 00000038H
	ret	0
?make_arena@d_std@@YAPEAUMemory_Arena@1@XZ ENDP		; d_std::make_arena
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
this$ = 48
?pop_all@Memory_Arena@d_std@@QEAAXXZ PROC		; d_std::Memory_Arena::pop_all

; 112  :     void Memory_Arena::pop_all(){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 113  : 
; 114  :         // Clear the arena, pop to the begining ( which is &arena + sizeof(Arena) )
; 115  :         pop_to(sizeof(Memory_Arena));

	mov	edx, 32					; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	call	?pop_to@Memory_Arena@d_std@@QEAAX_K@Z	; d_std::Memory_Arena::pop_to
	npad	1

; 116  : 
; 117  :     }

	add	rsp, 40					; 00000028H
	ret	0
?pop_all@Memory_Arena@d_std@@QEAAXXZ ENDP		; d_std::Memory_Arena::pop_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
next_commit_position$1 = 32
aligned_position$2 = 40
tv74 = 48
decommission_size$3 = 56
this$ = 80
position$ = 88
?pop_to@Memory_Arena@d_std@@QEAAX_K@Z PROC		; d_std::Memory_Arena::pop_to

; 91   :     void Memory_Arena::pop_to(u64 position){

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 92   : 
; 93   :         if(position < this->position){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR position$[rsp], rax
	jae	$LN2@pop_to

; 94   : 
; 95   :             this->position = position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR position$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 96   : 
; 97   :             u64 aligned_position = AlignPow2Up(this->position, DEFAULT_ARENA_COMMIT_SIZE);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 67108863				; 03ffffffH
	and	rax, -67108864				; fffffffffc000000H
	mov	QWORD PTR aligned_position$2[rsp], rax

; 98   :             u64 next_commit_position = d_min(aligned_position, this->capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR aligned_position$2[rsp], rax
	jae	SHORT $LN5@pop_to
	mov	rax, QWORD PTR aligned_position$2[rsp]
	mov	QWORD PTR tv74[rsp], rax
	jmp	SHORT $LN6@pop_to
$LN5@pop_to:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv74[rsp], rax
$LN6@pop_to:
	mov	rax, QWORD PTR tv74[rsp]
	mov	QWORD PTR next_commit_position$1[rsp], rax

; 99   : 
; 100  :             if(next_commit_position < this->commit_position){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR next_commit_position$1[rsp], rax
	jae	SHORT $LN3@pop_to

; 101  : 
; 102  :                 u64 decommission_size = this->commit_position - next_commit_position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR next_commit_position$1[rsp]
	mov	rax, QWORD PTR [rax+16]
	sub	rax, rcx
	mov	QWORD PTR decommission_size$3[rsp], rax

; 103  :                 d_decommit((u_ptr)(this + next_commit_position), decommission_size);

	imul	rax, QWORD PTR next_commit_position$1[rsp], 32 ; 00000020H
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR decommission_size$3[rsp]
	mov	rcx, rax
	call	?os_decommit_memory@d_std@@YAX_K0@Z	; d_std::os_decommit_memory

; 104  :                 this->commit_position = next_commit_position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR next_commit_position$1[rsp]
	mov	QWORD PTR [rax+16], rcx
$LN3@pop_to:
$LN2@pop_to:

; 105  : 
; 106  :             }
; 107  : 
; 108  :         }
; 109  : 
; 110  :     }

	add	rsp, 72					; 00000048H
	ret	0
?pop_to@Memory_Arena@d_std@@QEAAX_K@Z ENDP		; d_std::Memory_Arena::pop_to
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
memory$ = 32
aligned_position$1 = 40
tv89 = 48
commit_size$2 = 56
next_commit_position$3 = 64
this$ = 96
size$ = 104
?push@Memory_Arena@d_std@@QEAA_K_K@Z PROC		; d_std::Memory_Arena::push

; 66   :     u_ptr Memory_Arena::push(u64 size) {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 67   : 
; 68   :         u_ptr memory = 0;

	mov	QWORD PTR memory$[rsp], 0

; 69   :         if(size + this->position < capacity){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, QWORD PTR [rcx]
	jae	$LN2@push

; 70   :             if(size + this->position <= commit_position){

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR size$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR this$[rsp]
	cmp	rax, QWORD PTR [rcx+16]
	ja	SHORT $LN3@push

; 71   :                 memory = (u_ptr)this + this->position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR memory$[rsp], rax

; 72   :                 this->position += size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 73   :             } else {

	jmp	$LN4@push
$LN3@push:

; 74   : 
; 75   :                 memory = (u_ptr)this + this->position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR memory$[rsp], rax

; 76   :                 this->position += size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 77   : 
; 78   :                 u64 aligned_position = AlignPow2Up(this->position, DEFAULT_ARENA_COMMIT_SIZE);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, 67108863				; 03ffffffH
	and	rax, -67108864				; fffffffffc000000H
	mov	QWORD PTR aligned_position$1[rsp], rax

; 79   :                 u64 next_commit_position = d_min(aligned_position, this->capacity);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR aligned_position$1[rsp], rax
	jae	SHORT $LN6@push
	mov	rax, QWORD PTR aligned_position$1[rsp]
	mov	QWORD PTR tv89[rsp], rax
	jmp	SHORT $LN7@push
$LN6@push:
	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv89[rsp], rax
$LN7@push:
	mov	rax, QWORD PTR tv89[rsp]
	mov	QWORD PTR next_commit_position$3[rsp], rax

; 80   :                 u64 commit_size = next_commit_position - this->commit_position;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR next_commit_position$3[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR commit_size$2[rsp], rax

; 81   : 
; 82   :                 d_commit((u_ptr)this + this->commit_position, commit_size);

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR this$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rdx, QWORD PTR commit_size$2[rsp]
	mov	rcx, rax
	call	?os_commit_memory@d_std@@YAX_K0@Z	; d_std::os_commit_memory

; 83   :                 this->commit_position += commit_size;

	mov	rax, QWORD PTR this$[rsp]
	mov	rax, QWORD PTR [rax+16]
	add	rax, QWORD PTR commit_size$2[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	QWORD PTR [rcx+16], rax
$LN4@push:
$LN2@push:

; 84   : 
; 85   :             }
; 86   :         }
; 87   : 
; 88   :         return memory;

	mov	rax, QWORD PTR memory$[rsp]

; 89   :     }

	add	rsp, 88					; 00000058H
	ret	0
?push@Memory_Arena@d_std@@QEAA_K_K@Z ENDP		; d_std::Memory_Arena::push
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
tv65 = 32
this$ = 64
address$ = 72
?deallocate@Memory_Arena@d_std@@QEAAX_K@Z PROC		; d_std::Memory_Arena::deallocate

; 55   :     void Memory_Arena::deallocate(u_ptr address) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 56   : 
; 57   :         switch(this->type){

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@deallocate
	jmp	SHORT $LN2@deallocate
$LN4@deallocate:

; 58   :             case(Memory_Arena_Type_Linear):
; 59   :                 this->pop_to(address - (u_ptr)this);

	mov	rax, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR address$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	rdx, rax
	mov	rcx, QWORD PTR this$[rsp]
	call	?pop_to@Memory_Arena@d_std@@QEAAX_K@Z	; d_std::Memory_Arena::pop_to
	npad	1
$LN2@deallocate:

; 60   :                 break;
; 61   :         }
; 62   : 
; 63   :         return;
; 64   :     }

	add	rsp, 56					; 00000038H
	ret	0
?deallocate@Memory_Arena@d_std@@QEAAX_K@Z ENDP		; d_std::Memory_Arena::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
tv65 = 32
result$ = 40
this$ = 64
size$ = 72
?allocate@Memory_Arena@d_std@@QEAA_K_K@Z PROC		; d_std::Memory_Arena::allocate

; 43   :     u_ptr Memory_Arena::allocate(u64 size) {

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 44   : 
; 45   :         u_ptr result = 0;

	mov	QWORD PTR result$[rsp], 0

; 46   :         switch(this->type){

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@allocate
	jmp	SHORT $LN2@allocate
$LN4@allocate:

; 47   :             case(Memory_Arena_Type_Linear):
; 48   :                 result = this->push(size);

	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	call	?push@Memory_Arena@d_std@@QEAA_K_K@Z	; d_std::Memory_Arena::push
	mov	QWORD PTR result$[rsp], rax
$LN2@allocate:

; 49   :                 break;
; 50   :         }
; 51   : 
; 52   :         return result;

	mov	rax, QWORD PTR result$[rsp]

; 53   :     }

	add	rsp, 56					; 00000038H
	ret	0
?allocate@Memory_Arena@d_std@@QEAA_K_K@Z ENDP		; d_std::Memory_Arena::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
tv65 = 32
this$ = 64
?reset@Memory_Arena@d_std@@QEAAXXZ PROC			; d_std::Memory_Arena::reset

; 32   :     void Memory_Arena::reset() {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 33   : 
; 34   :         switch(this->type){

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN4@reset
	jmp	SHORT $LN2@reset
$LN4@reset:

; 35   :             case(Memory_Arena_Type_Linear):
; 36   :                 this->pop_all();

	mov	rcx, QWORD PTR this$[rsp]
	call	?pop_all@Memory_Arena@d_std@@QEAAXXZ	; d_std::Memory_Arena::pop_all
	npad	1
$LN2@reset:

; 37   :                 break;
; 38   :         }
; 39   : 
; 40   :         return;
; 41   :     }

	add	rsp, 56					; 00000038H
	ret	0
?reset@Memory_Arena@d_std@@QEAAXXZ ENDP			; d_std::Memory_Arena::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_memory.cpp
_TEXT	SEGMENT
this$ = 48
?release@Memory_Arena@d_std@@QEAAXXZ PROC		; d_std::Memory_Arena::release

; 27   :     void Memory_Arena::release() {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 28   :         d_release((u_ptr)this);

	mov	rcx, QWORD PTR this$[rsp]
	call	?os_release_memory@d_std@@YAX_K@Z	; d_std::os_release_memory
	npad	1

; 29   :         return;
; 30   :     }

	add	rsp, 40					; 00000028H
	ret	0
?release@Memory_Arena@d_std@@QEAAXXZ ENDP		; d_std::Memory_Arena::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
file$ = 48
?close_file@d_std@@YA_NUFile@1@@Z PROC			; d_std::close_file

; 227  :     bool close_file(File file){

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 228  :         if(CloseHandle(file.handle) == 0){

	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp_CloseHandle
	test	eax, eax
	jne	SHORT $LN2@close_file

; 229  :             os_debug_printf("close_file failed!", GetLastError());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG44919
	call	?os_debug_printf@d_std@@YAXPEBDZZ	; d_std::os_debug_printf

; 230  :             return false;

	xor	al, al
	jmp	SHORT $LN1@close_file
$LN2@close_file:

; 231  :         }
; 232  :         return true;

	mov	al, 1
$LN1@close_file:

; 233  :     }

	add	rsp, 40					; 00000028H
	ret	0
?close_file@d_std@@YA_NUFile@1@@Z ENDP			; d_std::close_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
num_bytes_read$ = 48
result$ = 52
__$ReturnAddress$ = 80
arena$ = 88
file$ = 96
bytes_to_read$ = 104
?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z PROC ; d_std::read_file

; 199  :     d_string read_file(Memory_Arena* arena, File file, u32 bytes_to_read){

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 200  :         d_string return_string;
; 201  :         return_string.string = arena->allocate_array<char>(bytes_to_read);

	mov	eax, DWORD PTR bytes_to_read$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 202  : 
; 203  :         DWORD num_bytes_read = 0;

	mov	DWORD PTR num_bytes_read$[rsp], 0

; 204  : 
; 205  :         BOOL result = ReadFile(

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR num_bytes_read$[rsp]
	mov	r8d, DWORD PTR bytes_to_read$[rsp]
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rax, QWORD PTR file$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp_ReadFile
	mov	DWORD PTR result$[rsp], eax

; 206  :             file.handle,
; 207  :             return_string.string,
; 208  :             bytes_to_read,
; 209  :             &num_bytes_read,
; 210  :             NULL
; 211  :         );
; 212  : 
; 213  :         if(result == 0){

	cmp	DWORD PTR result$[rsp], 0
	jne	SHORT $LN2@read_file

; 214  :             arena->deallocate_array(return_string.string);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rdx, QWORD PTR [rax]
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ; d_std::Memory_Arena::deallocate_array<char>

; 215  :             return_string.string = NULL;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rax], 0

; 216  :             return_string.size   = 0;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], 0

; 217  :             return return_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@read_file
$LN2@read_file:

; 218  :         }
; 219  : 
; 220  :         return_string.size = num_bytes_read;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR num_bytes_read$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 221  : 
; 222  :         arena->deallocate((u_ptr)return_string.string + num_bytes_read);

	mov	eax, DWORD PTR num_bytes_read$[rsp]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rdx, rax
	mov	rcx, QWORD PTR arena$[rsp]
	call	?deallocate@Memory_Arena@d_std@@QEAAX_K@Z ; d_std::Memory_Arena::deallocate

; 223  : 
; 224  :         return return_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@read_file:

; 225  :     }

	add	rsp, 72					; 00000048H
	ret	0
?read_file@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@UFile@1@I@Z ENDP ; d_std::read_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
dwDesiredAccess$ = 64
file_size$ = 68
os_file_handle$ = 72
__$ReturnAddress$ = 96
file_name$ = 104
permissions$ = 112
?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z PROC		; d_std::open_file

; 144  :     File open_file(const char* file_name, const char* permissions){

$LN12:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 145  : 
; 146  :         DWORD dwDesiredAccess = 0;

	mov	DWORD PTR dwDesiredAccess$[rsp], 0

; 147  : 
; 148  :         if(permissions != NULL){

	cmp	QWORD PTR permissions$[rsp], 0
	je	SHORT $LN2@open_file

; 149  :             // First Char
; 150  :             if(*permissions == 'r'){

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 114				; 00000072H
	jne	SHORT $LN3@open_file

; 151  :                 dwDesiredAccess |= GENERIC_READ;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 31
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
	jmp	SHORT $LN4@open_file
$LN3@open_file:

; 152  :             } else if (*permissions == 'w') {

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 119				; 00000077H
	jne	SHORT $LN5@open_file

; 153  :                 dwDesiredAccess |= GENERIC_WRITE;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 30
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
$LN5@open_file:
$LN4@open_file:

; 154  :             }
; 155  :             permissions++;

	mov	rax, QWORD PTR permissions$[rsp]
	inc	rax
	mov	QWORD PTR permissions$[rsp], rax

; 156  :             // Second Char
; 157  :             if(*permissions == 'r'){

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 114				; 00000072H
	jne	SHORT $LN6@open_file

; 158  :                 dwDesiredAccess |= GENERIC_READ;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 31
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
	jmp	SHORT $LN7@open_file
$LN6@open_file:

; 159  :             } else if (*permissions == 'w') {

	mov	rax, QWORD PTR permissions$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 119				; 00000077H
	jne	SHORT $LN8@open_file

; 160  :                 dwDesiredAccess |= GENERIC_WRITE;

	mov	eax, DWORD PTR dwDesiredAccess$[rsp]
	bts	eax, 30
	mov	DWORD PTR dwDesiredAccess$[rsp], eax
$LN8@open_file:
$LN7@open_file:
$LN2@open_file:

; 161  :             }
; 162  :         }
; 163  : 
; 164  : 
; 165  :         HANDLE os_file_handle = CreateFileA(

	mov	QWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, DWORD PTR dwDesiredAccess$[rsp]
	mov	rcx, QWORD PTR file_name$[rsp]
	call	QWORD PTR __imp_CreateFileA
	mov	QWORD PTR os_file_handle$[rsp], rax

; 166  :             file_name,
; 167  :             dwDesiredAccess,
; 168  :             0,
; 169  :             NULL,
; 170  :             OPEN_EXISTING,
; 171  :             FILE_ATTRIBUTE_NORMAL,
; 172  :             NULL
; 173  :         );
; 174  : 
; 175  :         if(os_file_handle == INVALID_HANDLE_VALUE){

	cmp	QWORD PTR os_file_handle$[rsp], -1
	jne	SHORT $LN9@open_file

; 176  :             os_debug_printf("open_file failed to create file handle! last error: %u", GetLastError());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG44902
	call	?os_debug_printf@d_std@@YAXPEBDZZ	; d_std::os_debug_printf

; 177  :             File error_file;
; 178  :             error_file.handle = INVALID_HANDLE_VALUE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rax], -1

; 179  :             error_file.size   = INVALID_FILE_SIZE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH

; 180  :             return error_file;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@open_file
$LN9@open_file:

; 181  :         }
; 182  : 
; 183  :         DWORD file_size = GetFileSize(os_file_handle, NULL);

	xor	edx, edx
	mov	rcx, QWORD PTR os_file_handle$[rsp]
	call	QWORD PTR __imp_GetFileSize
	mov	DWORD PTR file_size$[rsp], eax

; 184  :         if(file_size == INVALID_FILE_SIZE){

	cmp	DWORD PTR file_size$[rsp], -1		; ffffffffH
	jne	SHORT $LN10@open_file

; 185  :             os_debug_printf("open_file failed to get file size! last error: %u", GetLastError());

	call	QWORD PTR __imp_GetLastError
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG44904
	call	?os_debug_printf@d_std@@YAXPEBDZZ	; d_std::os_debug_printf

; 186  :             File error_file;
; 187  :             error_file.handle = INVALID_HANDLE_VALUE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rax], -1

; 188  :             error_file.size   = INVALID_FILE_SIZE;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], -1			; ffffffffH

; 189  :             return error_file;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	jmp	SHORT $LN1@open_file
$LN10@open_file:

; 190  :         }
; 191  : 
; 192  :         File return_file;
; 193  :         return_file.handle = os_file_handle;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR os_file_handle$[rsp]
	mov	QWORD PTR [rax], rcx

; 194  :         return_file.size   = file_size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR file_size$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 195  : 
; 196  :         return return_file;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
$LN1@open_file:

; 197  :     }

	add	rsp, 88					; 00000058H
	ret	0
?open_file@d_std@@YA?AUFile@1@PEBDQEBD@Z ENDP		; d_std::open_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
tv66 = 32
?is_debugger_present@d_std@@YA_NXZ PROC			; d_std::is_debugger_present

; 131  :     bool is_debugger_present(){

$LN5:
	sub	rsp, 56					; 00000038H

; 132  :         return  (bool) IsDebuggerPresent();

	call	QWORD PTR __imp_IsDebuggerPresent
	test	eax, eax
	je	SHORT $LN3@is_debugge
	mov	BYTE PTR tv66[rsp], 1
	jmp	SHORT $LN4@is_debugge
$LN3@is_debugge:
	mov	BYTE PTR tv66[rsp], 0
$LN4@is_debugge:
	movzx	eax, BYTE PTR tv66[rsp]

; 133  :     }

	add	rsp, 56					; 00000038H
	ret	0
?is_debugger_present@d_std@@YA_NXZ ENDP			; d_std::is_debugger_present
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
i$1 = 32
i$2 = 36
$T3 = 40
$T4 = 48
c_str$ = 64
__$ArrayPad$ = 576
string$ = 608
?os_debug_print@d_std@@YAXUd_string@1@@Z PROC		; d_std::os_debug_print

; 51   :     {

$LN15:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 600				; 00000258H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 52   : 
; 53   :         char c_str[501]; 
; 54   : 
; 55   :         if(string.size > 500){

	mov	rax, QWORD PTR string$[rsp]
	cmp	DWORD PTR [rax+8], 500			; 000001f4H
	jbe	$LN8@os_debug_p

; 56   : 
; 57   :             OutputDebugStringA("(os_debug_print) Error: string size is more than 500 characters. Printing first 500.\n");

	lea	rcx, OFFSET FLAT:$SG44840
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1

; 58   : 
; 59   :             for(int i = 0; i < 500; i++){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@os_debug_p
$LN2@os_debug_p:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@os_debug_p:
	cmp	DWORD PTR i$1[rsp], 500			; 000001f4H
	jge	SHORT $LN3@os_debug_p

; 60   :                 c_str[i] = string.string[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR i$1[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR c_str$[rsp+rdx], al

; 61   :             }

	jmp	SHORT $LN2@os_debug_p
$LN3@os_debug_p:

; 62   : 
; 63   :             c_str[500] = '\0';

	mov	eax, 1
	imul	rax, rax, 500				; 000001f4H
	mov	QWORD PTR $T3[rsp], rax
	cmp	QWORD PTR $T3[rsp], 501			; 000001f5H
	jae	SHORT $LN11@os_debug_p
	jmp	SHORT $LN12@os_debug_p
$LN11@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN12@os_debug_p:
	mov	rax, QWORD PTR $T3[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 64   : 
; 65   :             OutputDebugStringA(c_str);

	lea	rcx, QWORD PTR c_str$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1

; 66   :             
; 67   : 
; 68   :         } else {

	jmp	SHORT $LN9@os_debug_p
$LN8@os_debug_p:

; 69   : 
; 70   :             for(int i = 0; i < string.size; i++){

	mov	DWORD PTR i$2[rsp], 0
	jmp	SHORT $LN7@os_debug_p
$LN5@os_debug_p:
	mov	eax, DWORD PTR i$2[rsp]
	inc	eax
	mov	DWORD PTR i$2[rsp], eax
$LN7@os_debug_p:
	mov	rax, QWORD PTR string$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$2[rsp], eax
	jae	SHORT $LN6@os_debug_p

; 71   :                 c_str[i] = string.string[i];

	movsxd	rax, DWORD PTR i$2[rsp]
	mov	rcx, QWORD PTR string$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR i$2[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR c_str$[rsp+rdx], al

; 72   :             }

	jmp	SHORT $LN5@os_debug_p
$LN6@os_debug_p:

; 73   : 
; 74   :             c_str[string.size] = '\0';

	mov	rax, QWORD PTR string$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	QWORD PTR $T4[rsp], rax
	cmp	QWORD PTR $T4[rsp], 501			; 000001f5H
	jae	SHORT $LN13@os_debug_p
	jmp	SHORT $LN14@os_debug_p
$LN13@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN14@os_debug_p:
	mov	rax, QWORD PTR $T4[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 75   : 
; 76   :             OutputDebugStringA(c_str);

	lea	rcx, QWORD PTR c_str$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1
$LN9@os_debug_p:
$LN10@os_debug_p:

; 77   : 
; 78   :         }
; 79   : 
; 80   :         return;
; 81   : 
; 82   :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 600				; 00000258H
	ret	0
?os_debug_print@d_std@@YAXUd_string@1@@Z ENDP		; d_std::os_debug_print
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
$T1 = 32
va_args$ = 40
return_string$ = 48
$T2 = 64
$T3 = 80
c_str$ = 96
__$ArrayPad$ = 608
arena$ = 656
lit_string$ = 664
?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ PROC ; d_std::os_debug_printf

; 88   :     void __cdecl os_debug_printf(Memory_Arena *arena, char* lit_string, ...){

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rsi
	push	rdi
	sub	rsp, 632				; 00000278H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 89   : 
; 90   :         // va_list
; 91   :         u_ptr va_args;
; 92   : 
; 93   :         // va_start
; 94   :         va_args = (u_ptr)(&lit_string + 1);

	lea	rax, QWORD PTR lit_string$[rsp+8]
	mov	QWORD PTR va_args$[rsp], rax

; 95   : 
; 96   :         char c_str[501]; 
; 97   :         c_str[500] = '\0';

	mov	eax, 1
	imul	rax, rax, 500				; 000001f4H
	mov	QWORD PTR $T1[rsp], rax
	cmp	QWORD PTR $T1[rsp], 501			; 000001f5H
	jae	SHORT $LN3@os_debug_p
	jmp	SHORT $LN4@os_debug_p
$LN3@os_debug_p:
	call	__report_rangecheckfailure
	npad	1
$LN4@os_debug_p:
	mov	rax, QWORD PTR $T1[rsp]
	mov	BYTE PTR c_str$[rsp+rax], 0

; 98   : 
; 99   :         d_string return_string = _format_lit_string(arena, lit_string, va_args);

	mov	r9, QWORD PTR va_args$[rsp]
	mov	r8, QWORD PTR lit_string$[rsp]
	mov	rdx, QWORD PTR arena$[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	call	?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ; d_std::_format_lit_string
	lea	rcx, QWORD PTR return_string$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 100  : 
; 101  :         os_debug_print(return_string);

	lea	rax, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR return_string$[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb
	lea	rcx, QWORD PTR $T2[rsp]
	call	?os_debug_print@d_std@@YAXUd_string@1@@Z ; d_std::os_debug_print
	npad	1
$LN2@os_debug_p:

; 102  : 
; 103  :         return;
; 104  : 
; 105  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 632				; 00000278H
	pop	rdi
	pop	rsi
	ret	0
?os_debug_printf@d_std@@YAXPEAUMemory_Arena@1@PEADZZ ENDP ; d_std::os_debug_printf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
string$ = 48
?os_debug_print@d_std@@YAXPEBD@Z PROC			; d_std::os_debug_print

; 46   :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 47   :         OutputDebugStringA(string);

	mov	rcx, QWORD PTR string$[rsp]
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1

; 48   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_debug_print@d_std@@YAXPEBD@Z ENDP			; d_std::os_debug_print
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 48
?os_release_memory@d_std@@YAX_K@Z PROC			; d_std::os_release_memory

; 39   :     void os_release_memory (u_ptr memory){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 40   : 
; 41   :         VirtualFree((LPVOID)memory, 0, MEM_RELEASE);

	mov	r8d, 32768				; 00008000H
	xor	edx, edx
	mov	rcx, QWORD PTR memory$[rsp]
	call	QWORD PTR __imp_VirtualFree
	npad	1

; 42   : 
; 43   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_release_memory@d_std@@YAX_K@Z ENDP			; d_std::os_release_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 48
size$ = 56
?os_decommit_memory@d_std@@YAX_K0@Z PROC		; d_std::os_decommit_memory

; 33   :     void os_decommit_memory(u_ptr memory, u64 size){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 34   : 
; 35   :         VirtualFree((LPVOID)memory, size, MEM_DECOMMIT);

	mov	r8d, 16384				; 00004000H
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR memory$[rsp]
	call	QWORD PTR __imp_VirtualFree
	npad	1

; 36   : 
; 37   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_decommit_memory@d_std@@YAX_K0@Z ENDP		; d_std::os_decommit_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 48
size$ = 56
?os_commit_memory@d_std@@YAX_K0@Z PROC			; d_std::os_commit_memory

; 26   :     void os_commit_memory (u_ptr memory, u64 size){

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 27   : 
; 28   :         VirtualAlloc((LPVOID)memory, size, MEM_COMMIT, PAGE_READWRITE);

	mov	r9d, 4
	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR size$[rsp]
	mov	rcx, QWORD PTR memory$[rsp]
	call	QWORD PTR __imp_VirtualAlloc
	npad	1

; 29   :         return;
; 30   : 
; 31   :     }

	add	rsp, 40					; 00000028H
	ret	0
?os_commit_memory@d_std@@YAX_K0@Z ENDP			; d_std::os_commit_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\win32\d_os_win32.cpp
_TEXT	SEGMENT
memory$ = 32
size$ = 64
?os_reserve_memory@d_std@@YA_K_K@Z PROC			; d_std::os_reserve_memory

; 19   :     u_ptr os_reserve_memory (u64 size){

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 20   : 
; 21   :         u_ptr  memory = (u_ptr)VirtualAlloc(nullptr, size, MEM_RESERVE, PAGE_READWRITE);

	mov	r9d, 4
	mov	r8d, 8192				; 00002000H
	mov	rdx, QWORD PTR size$[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_VirtualAlloc
	mov	QWORD PTR memory$[rsp], rax

; 22   :         return memory;

	mov	rax, QWORD PTR memory$[rsp]

; 23   : 
; 24   :     }

	add	rsp, 56					; 00000038H
	ret	0
?os_reserve_memory@d_std@@YA_K_K@Z ENDP			; d_std::os_reserve_memory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
capacity$ = 32
temp$1 = 40
placement_ptr$2 = 48
it$ = 56
temp$3 = 64
placement_ptr$4 = 72
tv91 = 80
i$5 = 84
double_input$6 = 88
input_string_iterator$7 = 96
placement_ptr$8 = 104
placement_ptr$9 = 112
integer_part$10 = 120
number$11 = 128
decimal_part$12 = 136
c_str$13 = 144
d_str$14 = 152
__$ReturnAddress$ = 208
arena$ = 216
lit_string$ = 224
va_args$ = 232
?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z PROC ; d_std::_format_lit_string

; 308  :     d_string __cdecl _format_lit_string(Memory_Arena *arena, char* lit_string, u_ptr va_args){

$LN56:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 184				; 000000b8H

; 309  : 
; 310  :         // it iterates through the original string
; 311  :         char* it = lit_string;

	mov	rax, QWORD PTR lit_string$[rsp]
	mov	QWORD PTR it$[rsp], rax

; 312  : 
; 313  :         u32 capacity = 50;

	mov	DWORD PTR capacity$[rsp], 50		; 00000032H

; 314  :         d_string return_string;
; 315  : 
; 316  :         // Current place in new string is kept track of with size
; 317  :         return_string.string = arena->allocate_array<char>(capacity);

	mov	eax, DWORD PTR capacity$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 318  :         return_string.size = 0;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rax+8], 0
$LN2@format_lit:

; 319  : 
; 320  : 
; 321  :         while( *it != '\0'){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN3@format_lit
$LN4@format_lit:

; 322  : 
; 323  :             while( *it != '%' && *it != '\0'){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	je	$LN5@format_lit
	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN5@format_lit

; 324  :                 return_string.string[return_string.size] = *it;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rdx, QWORD PTR it$[rsp]
	movzx	edx, BYTE PTR [rdx]
	mov	BYTE PTR [rcx+rax], dl

; 325  :                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 326  :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 327  :                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN31@format_lit

; 328  :                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 329  :                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN31@format_lit:

; 330  :                 }
; 331  :             }

	jmp	$LN4@format_lit
$LN5@format_lit:

; 332  : 
; 333  :             if ( *it == '%' ) {

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax]
	cmp	eax, 37					; 00000025H
	jne	$LN32@format_lit

; 334  :                 if ( *(it+1) != '\0' ){

	mov	rax, QWORD PTR it$[rsp]
	movsx	eax, BYTE PTR [rax+1]
	test	eax, eax
	je	$LN33@format_lit

; 335  :                     
; 336  :                     // Switch based on argument type
; 337  :                     switch(*(it+1)){

	mov	rax, QWORD PTR it$[rsp]
	movzx	eax, BYTE PTR [rax+1]
	mov	BYTE PTR tv91[rsp], al
	cmp	BYTE PTR tv91[rsp], 36			; 00000024H
	je	$LN39@format_lit
	cmp	BYTE PTR tv91[rsp], 102			; 00000066H
	je	$LN41@format_lit
	cmp	BYTE PTR tv91[rsp], 115			; 00000073H
	je	$LN37@format_lit
	cmp	BYTE PTR tv91[rsp], 117			; 00000075H
	je	SHORT $LN34@format_lit
	jmp	$LN6@format_lit
$LN34@format_lit:

; 338  : 
; 339  :                         // Unsigned int
; 340  :                         case('u'):
; 341  :                         {
; 342  :                             u64 number = *(u64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR number$11[rsp], rax

; 343  :                             va_args += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 344  : 
; 345  :                             char* placement_ptr = return_string.string + return_string.size - 1;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rcx+rax-1]
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 346  : 
; 347  :                             // Guarantee one spot. What if "number" is 0?
; 348  :                             u64 temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 349  :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 350  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 351  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN35@format_lit

; 352  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 353  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN35@format_lit:

; 354  :                             }
; 355  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 356  : 
; 357  :                             // Find the reset of the space this number will take up in the string
; 358  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN10@format_lit
$LN8@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
$LN10@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN9@format_lit

; 359  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 360  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 361  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN36@format_lit

; 362  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 363  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN36@format_lit:

; 364  :                                 }
; 365  :                             }

	jmp	$LN8@format_lit
$LN9@format_lit:

; 366  : 
; 367  :                             // Insert the numbers from smallest (right) to largest (left)
; 368  :                             temp = number; 

	mov	rax, QWORD PTR number$11[rsp]
	mov	QWORD PTR temp$3[rsp], rax

; 369  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 370  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax

; 371  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax

; 372  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN13@format_lit
$LN11@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$3[rsp], rax
	mov	rax, QWORD PTR placement_ptr$4[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$4[rsp], rax
$LN13@format_lit:
	cmp	QWORD PTR temp$3[rsp], 0
	jbe	SHORT $LN12@format_lit

; 373  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$3[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$4[rsp]
	mov	BYTE PTR [rcx], al

; 374  :                             }

	jmp	SHORT $LN11@format_lit
$LN12@format_lit:

; 375  : 
; 376  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 377  :                         }
; 378  :                         break;

	jmp	$LN6@format_lit
$LN37@format_lit:

; 379  : 
; 380  :                         // C string
; 381  :                         case('s'):
; 382  :                         {
; 383  :                             char* c_str = *(char**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR c_str$13[rsp], rax

; 384  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 385  : 
; 386  :                             char* placement_ptr = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 387  : 
; 388  :                             char* input_string_iterator = (char*)c_str;

	mov	rax, QWORD PTR c_str$13[rsp]
	mov	QWORD PTR input_string_iterator$7[rsp], rax
$LN14@format_lit:

; 389  : 
; 390  :                             while(*input_string_iterator != '\0'){

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	$LN15@format_lit

; 391  : 
; 392  :                                 // Set char in output string 
; 393  :                                 *placement_ptr = *input_string_iterator;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	mov	rcx, QWORD PTR input_string_iterator$7[rsp]
	movzx	ecx, BYTE PTR [rcx]
	mov	BYTE PTR [rax], cl

; 394  : 
; 395  :                                 // Advance Iterators
; 396  :                                 input_string_iterator++;

	mov	rax, QWORD PTR input_string_iterator$7[rsp]
	inc	rax
	mov	QWORD PTR input_string_iterator$7[rsp], rax

; 397  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$8[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$8[rsp], rax

; 398  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 399  : 
; 400  :                                 // Possibly allocate more memory
; 401  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN38@format_lit

; 402  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 403  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN38@format_lit:

; 404  :                                 }
; 405  :                             }

	jmp	$LN14@format_lit
$LN15@format_lit:

; 406  : 
; 407  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 408  :                         }
; 409  :                         break;

	jmp	$LN6@format_lit
$LN39@format_lit:

; 410  : 
; 411  :                         // d_std::d_string
; 412  :                         case('$'):
; 413  :                         {
; 414  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 415  :                             d_string d_str = **(d_string**)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	mov	rax, QWORD PTR [rax]
	lea	rcx, QWORD PTR d_str$14[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb

; 416  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 417  : 
; 418  :                             char* placement_ptr = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 419  : 
; 420  :                             //char* input_string_iterator = (char*)d_str.string;
; 421  : 
; 422  :                             for(int i = 0; i < d_str.size; i++){

	mov	DWORD PTR i$5[rsp], 0
	jmp	SHORT $LN18@format_lit
$LN16@format_lit:
	mov	eax, DWORD PTR i$5[rsp]
	inc	eax
	mov	DWORD PTR i$5[rsp], eax
$LN18@format_lit:
	mov	eax, DWORD PTR d_str$14[rsp+8]
	cmp	DWORD PTR i$5[rsp], eax
	jae	$LN17@format_lit

; 423  : 
; 424  :                                 // Set char in output string 
; 425  :                                 *placement_ptr = d_str.string[i];

	movsxd	rax, DWORD PTR i$5[rsp]
	mov	rcx, QWORD PTR placement_ptr$9[rsp]
	mov	rdx, QWORD PTR d_str$14[rsp]
	movzx	eax, BYTE PTR [rdx+rax]
	mov	BYTE PTR [rcx], al

; 426  : 
; 427  :                                 // Advance Iterators
; 428  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$9[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$9[rsp], rax

; 429  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 430  : 
; 431  :                                 // Possibly allocate more memory
; 432  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN40@format_lit

; 433  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 434  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN40@format_lit:

; 435  :                                 }
; 436  :                             }

	jmp	$LN16@format_lit
$LN17@format_lit:

; 437  : 
; 438  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 439  :                         }
; 440  :                         break;

	jmp	$LN6@format_lit
$LN41@format_lit:

; 441  : 
; 442  :                         // d_std::d_string
; 443  :                         case('f'):
; 444  :                         {
; 445  :                             // Structs are added to the stack as the address of the stuct, and we have the address of that address
; 446  :                             double double_input = *(f64*)va_args;

	mov	rax, QWORD PTR va_args$[rsp]
	movsd	xmm0, QWORD PTR [rax]
	movsd	QWORD PTR double_input$6[rsp], xmm0

; 447  :                             va_args  += sizeof(u64);

	mov	rax, QWORD PTR va_args$[rsp]
	add	rax, 8
	mov	QWORD PTR va_args$[rsp], rax

; 448  : 
; 449  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN42@format_lit

; 450  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 451  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN42@format_lit:

; 452  :                             }
; 453  : 
; 454  :                             char* placement_ptr     = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 455  : 
; 456  :                             // Check and possibly add sign bit
; 457  :                             if(double_input < 0){

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR double_input$6[rsp]
	jbe	$LN43@format_lit

; 458  : 
; 459  :                                 // Add negative char in output string
; 460  :                                 *placement_ptr = '-';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 45			; 0000002dH

; 461  : 
; 462  :                                 // Advance Iterators
; 463  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 464  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 465  : 
; 466  :                                 // Possibly allocate more memory
; 467  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN44@format_lit

; 468  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 469  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN44@format_lit:

; 470  :                                 }
; 471  : 
; 472  :                                 double_input *= -1;

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	mulsd	xmm0, QWORD PTR __real@bff0000000000000
	movsd	QWORD PTR double_input$6[rsp], xmm0
$LN43@format_lit:

; 473  : 
; 474  :                             }
; 475  : 
; 476  :                             u64 integer_part = (u64)double_input;

	xor	eax, eax
	movsd	xmm0, QWORD PTR double_input$6[rsp]
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN55@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN55@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN55@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR integer_part$10[rsp], rax

; 477  : 
; 478  :                             // Guarantee one spot. What if "number" is 0?
; 479  :                             u64 temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 480  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 481  :                             // Possibly allocate more memory
; 482  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN45@format_lit

; 483  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 484  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN45@format_lit:

; 485  :                             }
; 486  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 487  : 
; 488  :                             // Find the reset of the space this number will take up in the string
; 489  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN21@format_lit
$LN19@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN21@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN20@format_lit

; 490  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 491  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 492  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN46@format_lit

; 493  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 494  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN46@format_lit:

; 495  :                                 }
; 496  :                             }

	jmp	$LN19@format_lit
$LN20@format_lit:

; 497  : 
; 498  :                             // Insert the numbers from smallest (right) to largest (left)
; 499  :                             temp = integer_part; 

	mov	rax, QWORD PTR integer_part$10[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 500  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 501  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 502  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 503  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN24@format_lit
$LN22@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN24@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN23@format_lit

; 504  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 505  :                             }

	jmp	SHORT $LN22@format_lit
$LN23@format_lit:

; 506  : 
; 507  :                             placement_ptr     = return_string.string + return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 508  : 
; 509  :                             // Insert decimal place
; 510  :                             *placement_ptr = '.';

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rax], 46			; 0000002eH

; 511  : 
; 512  :                             // Advance Iterators
; 513  :                             placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 514  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 515  : 
; 516  :                             // Possibly allocate more memory
; 517  :                             if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN47@format_lit

; 518  :                                 arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 519  :                                 capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN47@format_lit:

; 520  :                             }
; 521  : 
; 522  :                             u64 decimal_part = (((double_input + 0.00001 )- (float)integer_part) * 1000.);

	movsd	xmm0, QWORD PTR double_input$6[rsp]
	addsd	xmm0, QWORD PTR __real@3ee4f8b588e368f1
	mov	rax, QWORD PTR integer_part$10[rsp]
	test	rax, rax
	jl	SHORT $LN53@format_lit
	cvtsi2ss xmm1, rax
	jmp	SHORT $LN54@format_lit
$LN53@format_lit:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2ss xmm2, rcx
	addss	xmm2, xmm2
	movaps	xmm1, xmm2
$LN54@format_lit:
	cvtss2sd xmm1, xmm1
	subsd	xmm0, xmm1
	mulsd	xmm0, QWORD PTR __real@408f400000000000
	xor	eax, eax
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jb	SHORT $LN52@format_lit
	subsd	xmm0, QWORD PTR __real@43e0000000000000
	comisd	xmm0, QWORD PTR __real@43e0000000000000
	jae	SHORT $LN52@format_lit
	mov	rcx, -9223372036854775808		; 8000000000000000H
	add	rax, rcx
$LN52@format_lit:
	cvttsd2si rcx, xmm0
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR decimal_part$12[rsp], rax

; 523  : 
; 524  :                             // Guarantee one spot. What if "number" is 0?
; 525  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 526  :                             return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 527  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 528  : 
; 529  :                             // Find the reset of the space this number will take up in the string
; 530  :                             for(temp; temp>0; temp /= 10){

	jmp	SHORT $LN27@format_lit
$LN25@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
$LN27@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN26@format_lit

; 531  :                                 placement_ptr++;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	inc	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 532  :                                 return_string.size++;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	DWORD PTR [rcx+8], eax

; 533  :                                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN48@format_lit

; 534  :                                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 535  :                                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN48@format_lit:

; 536  :                                 }
; 537  :                             }

	jmp	$LN25@format_lit
$LN26@format_lit:

; 538  : 
; 539  :                             // Insert the numbers from smallest (right) to largest (left)
; 540  :                             temp = decimal_part; 

	mov	rax, QWORD PTR decimal_part$12[rsp]
	mov	QWORD PTR temp$1[rsp], rax

; 541  :                             *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 542  :                             temp /= 10;

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax

; 543  :                             placement_ptr--;

	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax

; 544  :                             for(temp; temp>0; temp /= 10, placement_ptr--){

	jmp	SHORT $LN30@format_lit
$LN28@format_lit:
	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	QWORD PTR temp$1[rsp], rax
	mov	rax, QWORD PTR placement_ptr$2[rsp]
	dec	rax
	mov	QWORD PTR placement_ptr$2[rsp], rax
$LN30@format_lit:
	cmp	QWORD PTR temp$1[rsp], 0
	jbe	SHORT $LN29@format_lit

; 545  :                                 *placement_ptr = (temp % 10) + '0';

	xor	edx, edx
	mov	rax, QWORD PTR temp$1[rsp]
	mov	ecx, 10
	div	rcx
	mov	rax, rdx
	add	rax, 48					; 00000030H
	mov	rcx, QWORD PTR placement_ptr$2[rsp]
	mov	BYTE PTR [rcx], al

; 546  :                             }

	jmp	SHORT $LN28@format_lit
$LN29@format_lit:

; 547  : 
; 548  :                             it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax
$LN6@format_lit:
$LN33@format_lit:

; 549  :                         }
; 550  :                         break;
; 551  :                     }
; 552  :                 }
; 553  :                 it++;

	mov	rax, QWORD PTR it$[rsp]
	inc	rax
	mov	QWORD PTR it$[rsp], rax

; 554  :                 if(return_string.size == capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jne	SHORT $LN49@format_lit

; 555  :                     arena->allocate_array<char>(return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>

; 556  :                     capacity += return_string.size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	ecx, DWORD PTR capacity$[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR capacity$[rsp], eax
$LN49@format_lit:
$LN32@format_lit:

; 557  :                 }
; 558  :             }
; 559  : 
; 560  :         }

	jmp	$LN2@format_lit
$LN3@format_lit:

; 561  : 
; 562  :         // Release memory from 
; 563  :         if(return_string.size < capacity){

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR capacity$[rsp]
	cmp	DWORD PTR [rax+8], ecx
	jae	SHORT $LN50@format_lit

; 564  :             arena->deallocate_array(return_string.string + return_string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	add	rax, QWORD PTR [rcx]
	mov	rdx, rax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$deallocate_array@D@Memory_Arena@d_std@@QEAAXPEAD@Z ; d_std::Memory_Arena::deallocate_array<char>
	npad	1
$LN50@format_lit:

; 565  :         }
; 566  : 
; 567  :         return return_string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 568  : 
; 569  :     }

	add	rsp, 184				; 000000b8H
	pop	rdi
	pop	rsi
	ret	0
?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ENDP ; d_std::_format_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
va_args$ = 32
$T1 = 40
__$ReturnAddress$ = 96
arena$ = 104
lit_string$ = 112
?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ PROC ; d_std::format_lit_string

; 39   :     d_string __cdecl format_lit_string(Memory_Arena *arena, char* lit_string, ...){

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	push	rsi
	push	rdi
	sub	rsp, 72					; 00000048H

; 40   : 
; 41   :         // va_list
; 42   :         u_ptr va_args;
; 43   : 
; 44   :         // va_start
; 45   :         va_args = (u_ptr)(&lit_string + 1);

	lea	rax, QWORD PTR lit_string$[rsp+8]
	mov	QWORD PTR va_args$[rsp], rax

; 46   : 
; 47   :         return _format_lit_string(arena, lit_string, va_args);

	mov	r9, QWORD PTR va_args$[rsp]
	mov	r8, QWORD PTR lit_string$[rsp]
	mov	rdx, QWORD PTR arena$[rsp]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	call	?_format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD_K@Z ; d_std::_format_lit_string
	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 48   : 
; 49   :     }

	add	rsp, 72					; 00000048H
	pop	rdi
	pop	rsi
	ret	0
?format_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEADZZ ENDP ; d_std::format_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
i$1 = 32
size$ = 36
p$ = 40
__$ReturnAddress$ = 64
arena$ = 72
lit_string$ = 80
?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z PROC ; d_std::string_from_lit_string

; 19   :     d_string string_from_lit_string(Memory_Arena *arena, char* lit_string){

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 20   : 
; 21   :         d_string string;
; 22   :         u32 size = 0;

	mov	DWORD PTR size$[rsp], 0

; 23   :         char* p = const_cast<char*>(lit_string);

	mov	rax, QWORD PTR lit_string$[rsp]
	mov	QWORD PTR p$[rsp], rax
$LN2@string_fro:

; 24   :         while (*p != '\0'){

	mov	rax, QWORD PTR p$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@string_fro

; 25   :             size++;

	mov	eax, DWORD PTR size$[rsp]
	inc	eax
	mov	DWORD PTR size$[rsp], eax

; 26   :             p++;

	mov	rax, QWORD PTR p$[rsp]
	inc	rax
	mov	QWORD PTR p$[rsp], rax

; 27   :         }

	jmp	SHORT $LN2@string_fro
$LN3@string_fro:

; 28   :         string.size = size;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	ecx, DWORD PTR size$[rsp]
	mov	DWORD PTR [rax+8], ecx

; 29   :         string.string = arena->allocate_array<char>(string.size);

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	QWORD PTR [rcx], rax

; 30   : 
; 31   :         for(int i = 0; i < string.size; i++){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN6@string_fro
$LN4@string_fro:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN6@string_fro:
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN5@string_fro

; 32   :             string.string[i] = lit_string[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rdx, QWORD PTR [rdx]
	mov	r8, QWORD PTR lit_string$[rsp]
	movzx	eax, BYTE PTR [r8+rax]
	mov	BYTE PTR [rdx+rcx], al

; 33   :         }

	jmp	SHORT $LN4@string_fro
$LN5@string_fro:

; 34   :         string.string[string.size] = '\0';

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR __$ReturnAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	BYTE PTR [rcx+rax], 0

; 35   : 
; 36   :         return string;

	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 37   :     }

	add	rsp, 56					; 00000038H
	ret	0
?string_from_lit_string@d_std@@YA?AUd_string@1@PEAUMemory_Arena@1@PEAD@Z ENDP ; d_std::string_from_lit_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\dev\computer_enhance_hw\d_core\d_string.cpp
_TEXT	SEGMENT
i$1 = 32
c_str$ = 40
this$ = 64
arena$ = 72
?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z PROC ; d_std::d_string::c_str

; 8    :     const char* d_string::c_str(Memory_Arena *arena){

$LN6:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 9    :         char* c_str = arena->allocate_array<char>(size + 1);

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	inc	eax
	mov	eax, eax
	mov	edx, eax
	mov	rcx, QWORD PTR arena$[rsp]
	call	??$allocate_array@D@Memory_Arena@d_std@@QEAAPEAD_K@Z ; d_std::Memory_Arena::allocate_array<char>
	mov	QWORD PTR c_str$[rsp], rax

; 10   : 
; 11   :         for(int i = 0; i < size; i++){

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@c_str
$LN2@c_str:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@c_str:
	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN3@c_str

; 12   :             c_str[i] = string[i];

	movsxd	rax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR this$[rsp]
	mov	rcx, QWORD PTR [rcx]
	movsxd	rdx, DWORD PTR i$1[rsp]
	mov	r8, QWORD PTR c_str$[rsp]
	movzx	eax, BYTE PTR [rcx+rax]
	mov	BYTE PTR [r8+rdx], al

; 13   :         }

	jmp	SHORT $LN2@c_str
$LN3@c_str:

; 14   :         c_str[size] = '\0';

	mov	rax, QWORD PTR this$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	rcx, QWORD PTR c_str$[rsp]
	mov	BYTE PTR [rcx+rax], 0

; 15   : 
; 16   :         return c_str;

	mov	rax, QWORD PTR c_str$[rsp]

; 17   :     }

	add	rsp, 56					; 00000038H
	ret	0
?c_str@d_string@d_std@@QEAAPEBDPEAUMemory_Arena@2@@Z ENDP ; d_std::d_string::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
tv77 = 48
tv75 = 56
_Format$ = 80
printf	PROC						; COMDAT

; 956  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 72					; 00000048H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	rax, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR tv77[rsp], rax
	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	QWORD PTR tv75[rsp], rax
	mov	r9, QWORD PTR tv77[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR tv75[rsp]
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 963  :     }

	add	rsp, 72					; 00000048H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
